<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FuXi&#39;s Daily</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-20T06:54:47.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dive into FutureTask</title>
    <link href="http://yoursite.com/2018/09/19/dive-into-AbstractQueuedSynchronizer/"/>
    <id>http://yoursite.com/2018/09/19/dive-into-AbstractQueuedSynchronizer/</id>
    <published>2018-09-19T07:49:48.000Z</published>
    <updated>2018-09-20T06:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>从上一个blog上学习到了ListenableFutureTask的设计和实现（之一），其中可知，ListenableFutureTask是继承了FutureTask的。关于FutureTask，FutureTask对象可以接收其他线程的执行结果，将同步操作改为异步操作，从而提高服务的响应时间和吞吐量。FutureTask底层使用了LockSupport实现线程间的通信，那么FutureTask是如何获取其他线程的执行结果的呢？又是如何取消任务的执行的呢？</p><h2 id="1-FutureTask的成员变量-amp-静态变量"><a href="#1-FutureTask的成员变量-amp-静态变量" class="headerlink" title="1.FutureTask的成员变量&amp;静态变量"></a>1.FutureTask的成员变量&amp;静态变量</h2><p>FutureTask的初始化有以下几种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 潜在的callable; nulled out after running */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure></p><p>其中FutureTask有上面几种状态，他们的转换方式如下：<br><img src="/image/futuretaskstate.webp" alt="FutureTask状态转换机"><br>其中2，3，4，6为终止状态。</p><p>其中，在调用get()方法时<strong>阻塞</strong>的线程会被构造成一个节点，加入到链表waiters中，waiters是链表的头结点（需要注意的是，并不是执行get()方法的线程都会被加入到改链表中）。<br>Waiter节点定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment"> * for more detailed explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>存储了线程和下一个节点信息，存储线程主要是为了知道唤醒哪一个线程。<br>从FutureTask的成员变量中可以看出，当实例化一个FutureTask对象时，必须传入一个callable对象，即便传入的是runnable对象，最终也会转变为callable对象。</p><h2 id="2-FutureTask构造函数"><a href="#2-FutureTask构造函数" class="headerlink" title="2.FutureTask构造函数"></a>2.FutureTask构造函数</h2><p>实例化FutureTask对象，必须传入callable对象，也可以传入runnable对象，其中第一种方法比较常见：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-执行FutureTask-run"><a href="#3-执行FutureTask-run" class="headerlink" title="3.执行FutureTask: run()"></a>3.执行FutureTask: run()</h2><p>线程池在调用submit()方法时，会将任务封装成一个FutureTask对象。<br>如下是run()方法的主题逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 执行任务前的状态检查与设置runner线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2. 执行任务</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//4.异常结果</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">//3. 正常执行结果</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">//5. 处理INTERRUPTING状态，就是等待一下</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>run()方法主要做了五件事情，其中主要涉及到上图中的状态转换图中的黑色内容，细节如下所示：</p><ol><li>任务运行前的状态检查<ul><li>任务状态必须为NEW，如果不为NEW，说明已经运行，直接返回；</li><li>如果任务状态为NEW，使用CAS操作设置该该任务的执行线程给runner，如果设置不成功，说明runner的值不为null，也就是说其他线程已经在执行该任务；如果设置成功，则进行后续操作。</li></ul></li><li>执行任务<ul><li>再次验证任务状态，因为其他的线程，在1，2之间可能会取消该任务，所以再次判断；</li><li>执行任务，调用callable 的 call()方法</li></ul></li><li><p>结果处理</p><ul><li>正常结果的处理代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the result of this future to the given value unless</span></span><br><span class="line"><span class="comment"> * this future has already been set or has been cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is invoked internally by the &#123;<span class="doctag">@link</span> #run&#125; method</span></span><br><span class="line"><span class="comment"> * upon successful completion of the computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v the value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>使用原子操作将状态转换成COMPLETING，表示任务执行完，但是还没给outcome（成员变量）赋值；</li><li>给outcome赋值；</li><li>使用原子操作将状态修改为normal，表示正常结束了；</li><li>完成后续操作，唤醒阻塞线程（在第四步介绍）；</li></ol></li><li>唤醒阻塞线程<ol><li>首先使用原子操作CAS移除所有的waiters，并且激活其中的thread;</li><li>依次遍历waiters中的节点，使用LockSupport.unpack()方法唤醒线程；</li><li>callable置空；</li></ol></li></ol><p><em>QUESTION</em>: 为什么要将callable置空？</p><p>源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="comment">//注意是对比q 和null，如果不为q，说明已经被其他线程改变，则失败；否则，清除并唤醒waiters中所有的thread。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//跳出外层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>等待interrupting状态的改变<br>run()方法的finally语句块中内容，因为interrupting状态不为最终状态，等待其变为最终状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that any interrupt from a possible cancel(true) is only</span></span><br><span class="line"><span class="comment"> * delivered to a task while in run or runAndReset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">    <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">    <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">    <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">    <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">    <span class="comment">// cancellation interrupt.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Thread.interrupted();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常处理<br>在run方法中，如果执行 callable.call() 的过程中出现异常时，则调用setException(ex)方法来处理异常，其中处理异常的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes this future to report an &#123;<span class="doctag">@link</span> ExecutionException&#125;</span></span><br><span class="line"><span class="comment"> * with the given throwable as its cause, unless this future has</span></span><br><span class="line"><span class="comment"> * already been set or has been cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is invoked internally by the &#123;<span class="doctag">@link</span> #run&#125; method</span></span><br><span class="line"><span class="comment"> * upon failure of the computation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the cause of failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可见，先通过原子操作CAS来讲状态更新为COMPLETING，然后将结果设置为t，然后再将状态设置为最终状态EXCEPTIONAL，并执行终止执行操作。</p><h2 id="3-获取FutureTask的结果：get"><a href="#3-获取FutureTask的结果：get" class="headerlink" title="3.获取FutureTask的结果：get()"></a>3.获取FutureTask的结果：get()</h2><p>FutureTask提供了两种获取任务结果的方法：</p><ol><li>get()阻塞方法，会一直阻塞到任务执行完成，才会返回；</li><li>get(long timeout, TimeUtil unit)方法，最长阻塞timeout时间，以便任务没有完成，也会返回；</li></ol><p>get()方法主要做了两件事情：</p><ol><li>判断任务状态，如果不为四种状态（可见状态排序），则执行awaitDone()方法；</li><li>任务结束，返回任务结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，主要的操作就是awaitDone()和report(s)，awaitDown()的作用是等待完成，或者在中断（或超时）时中止。<br>其中关于awaitDone()的源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> state upon completion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码中可以看出，并不是所有的调用get()方法的线程，就会进入阻塞链表，只有在调用get()方法时，任务状态为new的线程才会加入阻塞链表waiters中，等待任务执行完唤醒。如果任务执行完了，表明结果会快就会准备好，只需要自旋等待即可。具体的过程分析如下：</p><pre><code>1. 设置超时时间（如果存在的话）；2. 定义等待节点，如果需要构造等待节点（是有条件的），则构造并赋值给q；3. queued用于标记该阻塞节点是否已经插入到了链表中，防止多次插入；4. 使用死循环进行操作，（不完成目的不罢休，达到目的才会break）；5. 判断当前线程（注意，不是runner，而是当前线程，获取任务执行结果的线程）是否被中断，如果中断，则移出该线程的阻塞节点（removeWaiter()方法，如果没有阻塞节点，该方法直接返回），并抛出中断异常6. 如果任务已经执行完成（处于中止状态），将等待节点的线程置为空，**返回**状态；7. 如果任务已经执行完，但是没有给outcome赋值，则放弃CPU资源进行等待；(无break)8. 如果任务还未执行（即状态为NEW)，且无等待节点的，则构造等待节点；(无break)9. 如果任务还没有执行，并且存在等待节点的，则将等待节点加入到等待链表waiters中，通过CAS操作采用头插入法插入节点；(无break)10. 如果设置了超时，则判断有无超时，如果没有设置超时，则阻塞此线程，等待任务执行完执行finishCompletion()方法唤醒；(无break)11. 如果设置了超时，判断有无超时，如果超时，移除等待节点，**返回**状态；12. 如果没有超时，调用LockSupport 的parkNanos()方法进行超时等待；(无break)</code></pre><p><em>QUESTION:</em> 步骤5的原理是啥？可以对应到cancel中的中断方法，如果当前线程响应中断，则移除该线程的阻塞节点，并抛出异常。</p><p>在上述方法中，存在removeWaiter()方法，整体逻辑如下：</p><ol><li>判断传入的节点是否为null，如果为null直接返回；</li><li>如果不为空，首先将thread字段置null；</li><li>死循环，删除该thread字段为null节点；</li></ol><p>源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to unlink a timed-out or interrupted wait node to avoid</span></span><br><span class="line"><span class="comment"> * accumulating garbage.  Internal nodes are simply unspliced</span></span><br><span class="line"><span class="comment"> * without CAS since it is harmless if they are traversed anyway</span></span><br><span class="line"><span class="comment"> * by releasers.  To avoid effects of unsplicing from already</span></span><br><span class="line"><span class="comment"> * removed nodes, the list is retraversed in case of an apparent</span></span><br><span class="line"><span class="comment"> * race.  This is slow when there are a lot of nodes, but we don't</span></span><br><span class="line"><span class="comment"> * expect lists to be long enough to outweigh higher-overhead</span></span><br><span class="line"><span class="comment"> * schemes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                      q, s))</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其上删除逻辑就是寻找thread字段为null的节点的前节点，因为thread节点为null的就是我们要删除的节点。如果前节点存在，直接删除该节点，如果前节点不存在，说明该节点在链头，因为链表的插入操作采用的是头插法，因此，修改头结点会有线程安全问题，所以使用线程安全的CAS设置头结点的值，从而达到删除该节点的目的。如果原子操作没有删除成功，说明链表的结构发生了变化，需要重试。</p><p>get()方法中另外一个重要的方法是report(s)方法，其会根据不同的状态，返回不同的结果。源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-FutureTask的取消：cancel"><a href="#4-FutureTask的取消：cancel" class="headerlink" title="4.FutureTask的取消：cancel()"></a>4.FutureTask的取消：cancel()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.判断并对比状态</span></span><br><span class="line">    <span class="keyword">if</span> ((state != NEW) || !UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//2.runner线程的终端操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作对应状态转换图中的红线部分。</p><ol><li>当 mayInterruptIfRunning 为 false 时，表示cancel()方法只能响应已经提交但是还未执行的任务，其判断任务状态必须为NEW，且CAS操作将状态从NEW 置换为CANCELED成功时，会跳转到return true语句，即cancel成功；</li><li>当mayInterruptIfRunning 为true 时，前面的逻辑依旧成立，同时，cancel只能响应状态为NEW，且CAS操作将状态从NEW转换成INTERUPTING成功时，才<strong>可能</strong>完成取消操作；为何说可能呢？因为还需要执行线程响应该中断信号，如果执行线程不响应该信号，则该中断有没有是一样的，除非执行线程中存在影响中断的操作，否则，即便调用了interrupt()方法也不起任何作用；</li></ol><p>关于Java中的线程中断：可参见<a href="https://www.zhihu.com/question/41048032" target="_blank" rel="noopener">Java里一个线程调用了Thread.interrupt()到底意味着什么？</a></p><h2 id="5-辅助工具类"><a href="#5-辅助工具类" class="headerlink" title="5.辅助工具类"></a>5.辅助工具类</h2><p>使用线程安全工具Unsafe来保证线程安全的目的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = FutureTask.class;</span><br><span class="line">        stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">        runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"runner"</span>));</span><br><span class="line">        waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"waiters"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从上一个blog上学习到了ListenableFutureTask的设计和实现（之一），其中可知，ListenableFutureTask是继承了FutureTask的。关于FutureTask，FutureTask对象可以接收其他线程的执行结果，将同步操作改为异步操作，从
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dive into ListenableFuture</title>
    <link href="http://yoursite.com/2018/09/12/Dive-into-ListenableFuture/"/>
    <id>http://yoursite.com/2018/09/12/Dive-into-ListenableFuture/</id>
    <published>2018-09-12T11:49:01.000Z</published>
    <updated>2018-09-13T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要可监听的Future"><a href="#1-为什么要可监听的Future" class="headerlink" title="1.为什么要可监听的Future"></a>1.为什么要可监听的Future</h2><p>从java1.5开始，提供了Callback和Future，通过他们可以在任务执行完毕之后得到任务执行的结果。Future可以对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。<br>在java.util.concurrent包中，它是一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，在调用get()方法获取结果时，其会一直阻塞等待，直至计算完成，取得结果（当然，在这个线程未被取消，未被中断，未出现异常前提下)。或者还有另外一种方法就是不停调用isDone()来查看任务是否完成，一旦完成就调用get()方法获取结果。这样做，代码结构复杂，且效率低下，所以使用ListenableFuture可以帮助检测Future是否完成，如果完成了就自动调用回调函数，这样可以减少并发程序的复杂度。</p><h2 id="2-ListenableFuture"><a href="#2-ListenableFuture" class="headerlink" title="2.ListenableFuture"></a>2.ListenableFuture</h2><p>ListenableFuture是一个接口，其继承了Future的接口，达到可监听的目的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addListener</span><span class="params">(Runnable var1, Executor var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中val1是用来执行回调的Runnable, val2是用来执行val1。</p><h3 id="2-1初始化"><a href="#2-1初始化" class="headerlink" title="2.1初始化"></a>2.1初始化</h3><p>可以通过MoreExecutors类的静态方法初始化一个ListeningExecutorService的方法，然后使用此实例的submit方法即可初始化一个ListenableFuture对象，如listeningDecorator:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListeningExecutorService <span class="title">listeningDecorator</span><span class="params">(ExecutorService delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ListeningExecutorService)(delegate <span class="keyword">instanceof</span> ListeningExecutorService ? (ListeningExecutorService)delegate : (delegate <span class="keyword">instanceof</span> ScheduledExecutorService ? <span class="keyword">new</span> MoreExecutors.ScheduledListeningDecorator((ScheduledExecutorService)delegate) : <span class="keyword">new</span> MoreExecutors.ListeningDecorator(delegate)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中ListenableFutre的接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListeningExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; var1)</span></span>;</span><br><span class="line">    ListenableFuture&lt;?&gt; submit(Runnable var1);</span><br><span class="line">    &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable var1, T var2)</span></span>;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, <span class="keyword">long</span> var2, TimeUnit var4) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2使用ListenableFuture实例"><a href="#2-2使用ListenableFuture实例" class="headerlink" title="2.2使用ListenableFuture实例"></a>2.2使用ListenableFuture实例</h3><p>有了ListenableFuture实例，有两种方法可以执行此Future并执行Future完成之后的回调函数。</p><ul><li>方法一：通过ListenableFuture的addListener方法</li><li>方法二：通过Futures的静态方法addCallback给ListenableFuture添加回调函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(ListenableFuture&lt;V&gt; future, FutureCallback&lt;? <span class="keyword">super</span> V&gt; callback)</span> </span>&#123;</span><br><span class="line">        addCallback(future, callback, MoreExecutors.sameThreadExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(<span class="keyword">final</span> ListenableFuture&lt;V&gt; future,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> FutureCallback&lt;? <span class="keyword">super</span> V&gt; callback, Executor executor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(callback);</span><br><span class="line">    Runnable callbackListener = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> V value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TODO(user): (Before Guava release), validate that this</span></span><br><span class="line">          <span class="comment">// is the thing for IE.</span></span><br><span class="line">          value = getUninterruptibly(future);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">          callback.onFailure(e.getCause());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">          callback.onFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">          callback.onFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback.onSuccess(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    future.addListener(callbackListener, executor);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>其中可以看一下getUninteruptibly方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">V <span class="title">getUninterruptibly</span><span class="params">(Future&lt;V&gt; future)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object var2 = future.get();</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException var6) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>推荐使用第二种方法，因为第二种方法可以直接得到Future的返回值，或者处理错误情况。本质上第二种方法是通过调动第一种方法实现的，做了进一步的封装。</p><h2 id="3-ListenableFuture的实现之一：ListenableFutureTask"><a href="#3-ListenableFuture的实现之一：ListenableFutureTask" class="headerlink" title="3.ListenableFuture的实现之一：ListenableFutureTask"></a>3.ListenableFuture的实现之一：ListenableFutureTask</h2><p>ListenableFutureTask的实现逻辑如下，细节可见参考文档1<br><img src="/image/ListenableFutureTask.png" alt="ListenableFutureTask类图"></p><h2 id="4-总结-amp-思考"><a href="#4-总结-amp-思考" class="headerlink" title="4.总结&amp;思考"></a>4.总结&amp;思考</h2><p>其实我在读到使用推荐的方法二来进行添加回调的源代码时，就有一个疑问，即addCallback()方法只是在里面定义了一个Runnable来封装了回调的几个方法（成功，失败等），但是并没有有线程来执行这个Runnable，后面我读到 ListenableFutureTask 时，发现这个方法中的addListener方法，以及done()方法使用代理ExecutorList来通过我们生成的线程池运行了Runnable，就完整明白了其中的逻辑。</p><p>通过这次的ListenableFuture的分析学习，更加深刻的理解了Java中接口的意义，其实际上是约束了一组行为规范，但是并不具体实现，其可以认为是一个框架制定者，但是并不限制具体的实现。但是我们在实际的应用程序中，使用和接触的是实际的类对象实例，这个类如果实现了接口，就一定会实现这组行为规范，进行落地，让它真正的work起来。有时候在阅读代码或者编写代码时，就会容易犯我前面的糊涂，即担心Futures.addCallback()中的Runnable没人做，实际上我们写的时候是面向接口编程，但是在用的时候，是使用的实际的类，这些类就会完成实际的工作。这种思维无论是在阅读源码还是编写Java代码时，都是非常有用的。</p><h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><ol><li><a href="https://www.jianshu.com/p/a4b4159163fd" target="_blank" rel="noopener">《线程池系列六》-Guava ListenableFutureTask</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-为什么要可监听的Future&quot;&gt;&lt;a href=&quot;#1-为什么要可监听的Future&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要可监听的Future&quot;&gt;&lt;/a&gt;1.为什么要可监听的Future&lt;/h2&gt;&lt;p&gt;从java1.5开始，提供了
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s thread-safety</title>
    <link href="http://yoursite.com/2018/09/05/what-s-thread-safe/"/>
    <id>http://yoursite.com/2018/09/05/what-s-thread-safe/</id>
    <published>2018-09-05T11:53:11.000Z</published>
    <updated>2018-09-06T03:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-safety"><a href="#Thread-safety" class="headerlink" title="Thread safety"></a>Thread safety</h1><p>线程安全是应用在多线程代码上的一种计算机编程概念。线程安全的代码在操作共享的数据时保证了所有线程安全地按照逻辑进行执行，而不会出现意想不到的影响。有多重方法或策略来完成线程安全的数据结构。</p><p>应用程序可能在多个线程中执行同一段共享地址空间的代码，其中每一个线程可以访问到其他所有的线程中的内存。线程安全是一种允许代码执行在多线程环境中的性质，其通过<a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29" target="_blank" rel="noopener">同步</a>来重新建立实际控制流与程序文本之间的一些对应关系。</p><h2 id="1-线程安全的级别"><a href="#1-线程安全的级别" class="headerlink" title="1.线程安全的级别"></a>1.线程安全的级别</h2><p>软件库可以提供一些线程安全的保证。比如，并发地读文本可以保证是线程安全的，但是并发地写可能就不是。使用这种库的程序是否是线程安全的取决于它是否以与这些保证一致的方式来使用库。</p><p>不同的材料对线程安全使用略有不同的术语：</p><ul><li>线程安全的：实现上是保证在多个线程同时访问（执行）时竞争条件自由的。</li><li>条件安全的：不同的线程可以同时访问不同的对象，并且，对共享的数据是被保护起来免于竞争的。</li><li>线程不全的：代码不能被不同的线程同时访问（执行）。</li></ul><p>线程安全保证通常还包括防止或者限制不同形式的死锁的风险的设计步骤，以及并发性能最大化的优化。但是，无法始终给出无死锁保证，因为死锁可能是由回调和违反独立于库本身的架构分层引起的。</p><h2 id="2-方法的实现"><a href="#2-方法的实现" class="headerlink" title="2.方法的实现"></a>2.方法的实现</h2><p>下面讨论两种方法来达到避免条件竞争的目的。其中，第一种方法专注于避免共享状态，包括如下：</p><ul><li><a href="https://en.wikipedia.org/wiki/Reentrancy_%28computing%29" target="_blank" rel="noopener">可重入性</a><br>以这样的方式编写代码，使其可以由一个线程部分地执行，由同一个线程重新执行或者有另外一个线程同时执行，并依然正确的完成原始的操作。这需要将状态信息保存在每个执行的本地变量中，通常在堆栈上，而不是静态或全局变量或其他非本地状态。 必须通过原子操作访问所有非本地状态，并且数据结构也必须是可重入的。</li><li><a href="https://en.wikipedia.org/wiki/Thread-local_storage#Java" target="_blank" rel="noopener">线程本地存储</a><br>变量已本地化，因此每个线程都有自己的私有副本。 这些变量在子例程和其他代码边界中保留其值，并且是线程安全的，因为它们对于每个线程是本地的，即使访问它们的代码可能由另一个线程同时执行。</li><li><a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变对象</a><br>对象的状态在构建后不可改变。这意味着只共享只读数据并获得固有的线程安全性。 然后可以以这样的方式实现可变（非常量）操作，即它们创建新对象而不是修改现有对象。 这种方法是函数式编程的特征，也可用于Java，C＃和Python中的字符串实现。</li></ul><p>第二种类型的方法是与同步相关的，其被使用在共享状态是无法避免的情况下:</p><ul><li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion" target="_blank" rel="noopener">互斥</a><br>使用确保只有一个线程可以随时读取或写入共享数据的机制来串行化对共享数据的访问。合并互斥需要经过深思熟虑，因为不当使用会导致诸如死锁，活锁和资源匮乏等副作用。</li><li><a href="https://en.wikipedia.org/wiki/Linearizability" target="_blank" rel="noopener">原子操作</a><br>通过使用不能被其他线程中断的原子操作来访问共享数据。 这通常需要使用特殊的机器语言指令，这些指令可能在运行时库中可用。 由于操作是原子操作，因此无论其他线程如何访问它，共享数据始终保持有效状态。 原子操作构成了许多线程锁定机制的基础，并用于实现互斥原语。</li></ul><h2 id="3-样例"><a href="#3-样例" class="headerlink" title="3.样例"></a>3.样例</h2><p>如下例子是一段Java代码，方法是线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在C语言中，每一个线程都有自己的栈，但是，静态变量是不存放在栈中。所有的线程同时的访问它。如果多个线程同时运行，则一个线程可能会改变静态变量，而另一个线程可能会在一个线程更改途中检查它，造成不合意的事情发生。这种难以诊断的逻辑错误，可以在大多数时间编译和运行正常，成为竞争条件。避免这种情况的一种常见的方法是使用另一个共享变量作为“锁定”或“互斥”。</p><p>在下面的一段C语言代码中，方法是线程安全的，但是不可重入的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increment_counter</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// only allow one thread to increment at a time</span></span><br><span class="line"> pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"> ++counter;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// store value before any other threads increment it further</span></span><br><span class="line"> <span class="keyword">int</span> result = counter;</span><br><span class="line"></span><br><span class="line"> pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面，increment_counter可以由不同的线程调用而没有任何问题，因为互斥锁用于同步对共享计数器变量的所有访问。 但是如果函数在重入中断处理程序中使用并且函数内部出现第二个中断，则第二个例程将永久挂起。 由于中断服务可以禁用其他中断，整个系统可能会受到影响。</p><p>使用C++11中的无锁原子，可以将相同的函数实现为线程安全和可重入的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increment_counter</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; counter(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// increment is guaranteed to be done atomically</span></span><br><span class="line"> <span class="keyword">int</span> result = ++counter;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><ul><li><a href="https://en.wikipedia.org/wiki/Concurrency_control" target="_blank" rel="noopener">Concurrency control</a></li><li><a href="https://en.wikipedia.org/wiki/Exception_safety" target="_blank" rel="noopener">Exception safety</a></li><li><a href="https://en.wikipedia.org/wiki/Priority_inversion" target="_blank" rel="noopener">Priority inversion</a></li><li><a href="https://en.wikipedia.org/wiki/ThreadSafe" target="_blank" rel="noopener">ThreadSafe</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Thread-safety&quot;&gt;&lt;a href=&quot;#Thread-safety&quot; class=&quot;headerlink&quot; title=&quot;Thread safety&quot;&gt;&lt;/a&gt;Thread safety&lt;/h1&gt;&lt;p&gt;线程安全是应用在多线程代码上的一种计算机编程概念。线
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java exception</title>
    <link href="http://yoursite.com/2018/08/22/Java-exception/"/>
    <id>http://yoursite.com/2018/08/22/Java-exception/</id>
    <published>2018-08-22T02:39:49.000Z</published>
    <updated>2018-08-22T03:18:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Java 异常时定义在程序执行时，出现异常情况或问题的对象。其通常使用try….catch代码块来抛出以及捕捉。其中，需要注意的是，异常和错误在程序中是不同的；错误表示程序无法正常恢复，而异常，一般来说是可以处理的问题，例如除法中分母为0的情况。</p><p>异常代表着在程序执行过程中需要特别注意的一些异常的情况或者问题，对于这些问题，在它们出现之前进行处理是可能的。</p><h2 id="2-Java异常分类"><a href="#2-Java异常分类" class="headerlink" title="2.Java异常分类"></a>2.Java异常分类</h2><p>Java对异常的组织是比较简单的，其中所有的错误和异常都继承自Throwable。其中错误以及运行时异常都是未受检异常，这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的而或者引发了内部状态的改变导致的。那么这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止，让调用者对代码进行修正。如我上面例子的ArrayIndexOutOfBoundsException就是这类异常。</p><p>对于已检查异常，只要是Exception和其子类都是，除了特殊子类RuntimeException体系。 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。这样的问题都可以针对性的处理。如ClassNotFoundException就是这类异常。</p><p><img src="/image/built_in_exception.png" alt="Exception class hierarchy"></p><h2 id="3-实际中处理异常的原则"><a href="#3-实际中处理异常的原则" class="headerlink" title="3.实际中处理异常的原则"></a>3.实际中处理异常的原则</h2><ol><li>函数内容如果抛出已检查的异常，那么函数上必须要声明。否则必须在函数内用try-catch捕获，否则编译失败。</li><li>如果调用到了声明已检查异常的函数，要么try-catch要么throws，否则编译失败。</li><li>什么时候catch，什么时候throws 呢？功能内容可以解决，用catch。解决不了，用throws告诉调用者，由调用者解决 。</li><li>一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。内部又几个需要检测的异常，就抛几个异常，抛出几个，就catch几个。</li></ol><h2 id="4-参考资源"><a href="#4-参考资源" class="headerlink" title="4.参考资源"></a>4.参考资源</h2><ol><li><a href="https://blog.csdn.net/TimHeath/article/details/53504328" target="_blank" rel="noopener">Java异常介绍</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/index.html" target="_blank" rel="noopener">Java 异常处理的误区和经验总结</a></li><li><a href="https://www.developer.com/java/data/understanding-exception-handling-in-java.html" target="_blank" rel="noopener">Understanding Exception Handling in Java</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;Java 异常时定义在程序执行时，出现异常情况或问题的对象。其通常使用try….catch代码块来抛出以及捕捉。其中，需要注
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Cognition</title>
    <link href="http://yoursite.com/2018/08/03/Cognition/"/>
    <id>http://yoursite.com/2018/08/03/Cognition/</id>
    <published>2018-08-03T01:58:57.000Z</published>
    <updated>2018-09-19T07:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>人与人之间的差别从认知开始，又以认知结束，并且是一个不断自我强化的过程。</li><li>细致入微地观察，仔细全面地阅读，深刻痛苦地思考，平等热烈地讨论，积极高效地执行，细致入微的观察。</li><li>君子不器，不要给自己设限。</li><li>系统化的调研学习是非常重要的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;人与人之间的差别从认知开始，又以认知结束，并且是一个不断自我强化的过程。&lt;/li&gt;
&lt;li&gt;细致入微地观察，仔细全面地阅读，深刻痛苦地思考，平等热烈地讨论，积极高效地执行，细致入微的观察。&lt;/li&gt;
&lt;li&gt;君子不器，不要给自己设限。&lt;/li&gt;
&lt;li&gt;系统化的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/02/hello-world/"/>
    <id>http://yoursite.com/2018/08/02/hello-world/</id>
    <published>2018-08-02T09:40:45.000Z</published>
    <updated>2018-08-02T09:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
