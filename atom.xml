<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FuXi&#39;s Daily</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-13T08:14:36.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dive into ListenableFuture</title>
    <link href="http://yoursite.com/2018/09/12/Dive-into-ListenableFuture/"/>
    <id>http://yoursite.com/2018/09/12/Dive-into-ListenableFuture/</id>
    <published>2018-09-12T11:49:01.000Z</published>
    <updated>2018-09-13T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要可监听的Future"><a href="#1-为什么要可监听的Future" class="headerlink" title="1.为什么要可监听的Future"></a>1.为什么要可监听的Future</h2><p>从java1.5开始，提供了Callback和Future，通过他们可以在任务执行完毕之后得到任务执行的结果。Future可以对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。<br>在java.util.concurrent包中，它是一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，在调用get()方法获取结果时，其会一直阻塞等待，直至计算完成，取得结果（当然，在这个线程未被取消，未被中断，未出现异常前提下)。或者还有另外一种方法就是不停调用isDone()来查看任务是否完成，一旦完成就调用get()方法获取结果。这样做，代码结构复杂，且效率低下，所以使用ListenableFuture可以帮助检测Future是否完成，如果完成了就自动调用回调函数，这样可以减少并发程序的复杂度。</p><h2 id="2-ListenableFuture"><a href="#2-ListenableFuture" class="headerlink" title="2.ListenableFuture"></a>2.ListenableFuture</h2><p>ListenableFuture是一个接口，其继承了Future的接口，达到可监听的目的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addListener</span><span class="params">(Runnable var1, Executor var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中val1是用来执行回调的Runnable, val2是用来执行val1。</p><h3 id="2-1初始化"><a href="#2-1初始化" class="headerlink" title="2.1初始化"></a>2.1初始化</h3><p>可以通过MoreExecutors类的静态方法初始化一个ListeningExecutorService的方法，然后使用此实例的submit方法即可初始化一个ListenableFuture对象，如listeningDecorator:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListeningExecutorService <span class="title">listeningDecorator</span><span class="params">(ExecutorService delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ListeningExecutorService)(delegate <span class="keyword">instanceof</span> ListeningExecutorService ? (ListeningExecutorService)delegate : (delegate <span class="keyword">instanceof</span> ScheduledExecutorService ? <span class="keyword">new</span> MoreExecutors.ScheduledListeningDecorator((ScheduledExecutorService)delegate) : <span class="keyword">new</span> MoreExecutors.ListeningDecorator(delegate)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中ListenableFutre的接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListeningExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; var1)</span></span>;</span><br><span class="line">    ListenableFuture&lt;?&gt; submit(Runnable var1);</span><br><span class="line">    &lt;T&gt; <span class="function">ListenableFuture&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable var1, T var2)</span></span>;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; var1, <span class="keyword">long</span> var2, TimeUnit var4) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2使用ListenableFuture实例"><a href="#2-2使用ListenableFuture实例" class="headerlink" title="2.2使用ListenableFuture实例"></a>2.2使用ListenableFuture实例</h3><p>有了ListenableFuture实例，有两种方法可以执行此Future并执行Future完成之后的回调函数。</p><ul><li>方法一：通过ListenableFuture的addListener方法</li><li>方法二：通过Futures的静态方法addCallback给ListenableFuture添加回调函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(ListenableFuture&lt;V&gt; future, FutureCallback&lt;? <span class="keyword">super</span> V&gt; callback)</span> </span>&#123;</span><br><span class="line">        addCallback(future, callback, MoreExecutors.sameThreadExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(<span class="keyword">final</span> ListenableFuture&lt;V&gt; future,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> FutureCallback&lt;? <span class="keyword">super</span> V&gt; callback, Executor executor)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkNotNull(callback);</span><br><span class="line">    Runnable callbackListener = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> V value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// TODO(user): (Before Guava release), validate that this</span></span><br><span class="line">          <span class="comment">// is the thing for IE.</span></span><br><span class="line">          value = getUninterruptibly(future);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">          callback.onFailure(e.getCause());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">          callback.onFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">          callback.onFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback.onSuccess(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    future.addListener(callbackListener, executor);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>其中可以看一下getUninteruptibly方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;V&gt; <span class="function">V <span class="title">getUninterruptibly</span><span class="params">(Future&lt;V&gt; future)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object var2 = future.get();</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException var6) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>推荐使用第二种方法，因为第二种方法可以直接得到Future的返回值，或者处理错误情况。本质上第二种方法是通过调动第一种方法实现的，做了进一步的封装。</p><h2 id="3-ListenableFuture的实现之一：ListenableFutureTask"><a href="#3-ListenableFuture的实现之一：ListenableFutureTask" class="headerlink" title="3.ListenableFuture的实现之一：ListenableFutureTask"></a>3.ListenableFuture的实现之一：ListenableFutureTask</h2><p>ListenableFutureTask的实现逻辑如下，细节可见参考文档1<br><img src="/image/ListenableFutureTask.png" alt="ListenableFutureTask类图"></p><h2 id="4-总结-amp-思考"><a href="#4-总结-amp-思考" class="headerlink" title="4.总结&amp;思考"></a>4.总结&amp;思考</h2><p>其实我在读到使用推荐的方法二来进行添加回调的源代码时，就有一个疑问，即addCallback()方法只是在里面定义了一个Runnable来封装了回调的几个方法（成功，失败等），但是并没有有线程来执行这个Runnable，后面我读到 ListenableFutureTask 时，发现这个方法中的addListener方法，以及done()方法使用代理ExecutorList来通过我们生成的线程池运行了Runnable，就完整明白了其中的逻辑。</p><p>通过这次的ListenableFuture的分析学习，更加深刻的理解了Java中接口的意义，其实际上是约束了一组行为规范，但是并不具体实现，其可以认为是一个框架制定者，但是并不限制具体的实现。但是我们在实际的应用程序中，使用和接触的是实际的类对象实例，这个类如果实现了接口，就一定会实现这组行为规范，进行落地，让它真正的work起来。有时候在阅读代码或者编写代码时，就会容易犯我前面的糊涂，即担心Futures.addCallback()中的Runnable没人做，实际上我们写的时候是面向接口编程，但是在用的时候，是使用的实际的类，这些类就会完成实际的工作。这种思维无论是在阅读源码还是编写Java代码时，都是非常有用的。</p><h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><ol><li><a href="https://www.jianshu.com/p/a4b4159163fd" target="_blank" rel="noopener">《线程池系列六》-Guava ListenableFutureTask</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-为什么要可监听的Future&quot;&gt;&lt;a href=&quot;#1-为什么要可监听的Future&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要可监听的Future&quot;&gt;&lt;/a&gt;1.为什么要可监听的Future&lt;/h2&gt;&lt;p&gt;从java1.5开始，提供了
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s thread-safety</title>
    <link href="http://yoursite.com/2018/09/05/what-s-thread-safe/"/>
    <id>http://yoursite.com/2018/09/05/what-s-thread-safe/</id>
    <published>2018-09-05T11:53:11.000Z</published>
    <updated>2018-09-06T03:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-safety"><a href="#Thread-safety" class="headerlink" title="Thread safety"></a>Thread safety</h1><p>线程安全是应用在多线程代码上的一种计算机编程概念。线程安全的代码在操作共享的数据时保证了所有线程安全地按照逻辑进行执行，而不会出现意想不到的影响。有多重方法或策略来完成线程安全的数据结构。</p><p>应用程序可能在多个线程中执行同一段共享地址空间的代码，其中每一个线程可以访问到其他所有的线程中的内存。线程安全是一种允许代码执行在多线程环境中的性质，其通过<a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29" target="_blank" rel="noopener">同步</a>来重新建立实际控制流与程序文本之间的一些对应关系。</p><h2 id="1-线程安全的级别"><a href="#1-线程安全的级别" class="headerlink" title="1.线程安全的级别"></a>1.线程安全的级别</h2><p>软件库可以提供一些线程安全的保证。比如，并发地读文本可以保证是线程安全的，但是并发地写可能就不是。使用这种库的程序是否是线程安全的取决于它是否以与这些保证一致的方式来使用库。</p><p>不同的材料对线程安全使用略有不同的术语：</p><ul><li>线程安全的：实现上是保证在多个线程同时访问（执行）时竞争条件自由的。</li><li>条件安全的：不同的线程可以同时访问不同的对象，并且，对共享的数据是被保护起来免于竞争的。</li><li>线程不全的：代码不能被不同的线程同时访问（执行）。</li></ul><p>线程安全保证通常还包括防止或者限制不同形式的死锁的风险的设计步骤，以及并发性能最大化的优化。但是，无法始终给出无死锁保证，因为死锁可能是由回调和违反独立于库本身的架构分层引起的。</p><h2 id="2-方法的实现"><a href="#2-方法的实现" class="headerlink" title="2.方法的实现"></a>2.方法的实现</h2><p>下面讨论两种方法来达到避免条件竞争的目的。其中，第一种方法专注于避免共享状态，包括如下：</p><ul><li><a href="https://en.wikipedia.org/wiki/Reentrancy_%28computing%29" target="_blank" rel="noopener">可重入性</a><br>以这样的方式编写代码，使其可以由一个线程部分地执行，由同一个线程重新执行或者有另外一个线程同时执行，并依然正确的完成原始的操作。这需要将状态信息保存在每个执行的本地变量中，通常在堆栈上，而不是静态或全局变量或其他非本地状态。 必须通过原子操作访问所有非本地状态，并且数据结构也必须是可重入的。</li><li><a href="https://en.wikipedia.org/wiki/Thread-local_storage#Java" target="_blank" rel="noopener">线程本地存储</a><br>变量已本地化，因此每个线程都有自己的私有副本。 这些变量在子例程和其他代码边界中保留其值，并且是线程安全的，因为它们对于每个线程是本地的，即使访问它们的代码可能由另一个线程同时执行。</li><li><a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可变对象</a><br>对象的状态在构建后不可改变。这意味着只共享只读数据并获得固有的线程安全性。 然后可以以这样的方式实现可变（非常量）操作，即它们创建新对象而不是修改现有对象。 这种方法是函数式编程的特征，也可用于Java，C＃和Python中的字符串实现。</li></ul><p>第二种类型的方法是与同步相关的，其被使用在共享状态是无法避免的情况下:</p><ul><li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion" target="_blank" rel="noopener">互斥</a><br>使用确保只有一个线程可以随时读取或写入共享数据的机制来串行化对共享数据的访问。合并互斥需要经过深思熟虑，因为不当使用会导致诸如死锁，活锁和资源匮乏等副作用。</li><li><a href="https://en.wikipedia.org/wiki/Linearizability" target="_blank" rel="noopener">原子操作</a><br>通过使用不能被其他线程中断的原子操作来访问共享数据。 这通常需要使用特殊的机器语言指令，这些指令可能在运行时库中可用。 由于操作是原子操作，因此无论其他线程如何访问它，共享数据始终保持有效状态。 原子操作构成了许多线程锁定机制的基础，并用于实现互斥原语。</li></ul><h2 id="3-样例"><a href="#3-样例" class="headerlink" title="3.样例"></a>3.样例</h2><p>如下例子是一段Java代码，方法是线程安全的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在C语言中，每一个线程都有自己的栈，但是，静态变量是不存放在栈中。所有的线程同时的访问它。如果多个线程同时运行，则一个线程可能会改变静态变量，而另一个线程可能会在一个线程更改途中检查它，造成不合意的事情发生。这种难以诊断的逻辑错误，可以在大多数时间编译和运行正常，成为竞争条件。避免这种情况的一种常见的方法是使用另一个共享变量作为“锁定”或“互斥”。</p><p>在下面的一段C语言代码中，方法是线程安全的，但是不可重入的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increment_counter</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// only allow one thread to increment at a time</span></span><br><span class="line"> pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"> ++counter;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// store value before any other threads increment it further</span></span><br><span class="line"> <span class="keyword">int</span> result = counter;</span><br><span class="line"></span><br><span class="line"> pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面，increment_counter可以由不同的线程调用而没有任何问题，因为互斥锁用于同步对共享计数器变量的所有访问。 但是如果函数在重入中断处理程序中使用并且函数内部出现第二个中断，则第二个例程将永久挂起。 由于中断服务可以禁用其他中断，整个系统可能会受到影响。</p><p>使用C++11中的无锁原子，可以将相同的函数实现为线程安全和可重入的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increment_counter</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; counter(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// increment is guaranteed to be done atomically</span></span><br><span class="line"> <span class="keyword">int</span> result = ++counter;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4.参考链接"></a>4.参考链接</h2><ul><li><a href="https://en.wikipedia.org/wiki/Concurrency_control" target="_blank" rel="noopener">Concurrency control</a></li><li><a href="https://en.wikipedia.org/wiki/Exception_safety" target="_blank" rel="noopener">Exception safety</a></li><li><a href="https://en.wikipedia.org/wiki/Priority_inversion" target="_blank" rel="noopener">Priority inversion</a></li><li><a href="https://en.wikipedia.org/wiki/ThreadSafe" target="_blank" rel="noopener">ThreadSafe</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Thread-safety&quot;&gt;&lt;a href=&quot;#Thread-safety&quot; class=&quot;headerlink&quot; title=&quot;Thread safety&quot;&gt;&lt;/a&gt;Thread safety&lt;/h1&gt;&lt;p&gt;线程安全是应用在多线程代码上的一种计算机编程概念。线
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java exception</title>
    <link href="http://yoursite.com/2018/08/22/Java-exception/"/>
    <id>http://yoursite.com/2018/08/22/Java-exception/</id>
    <published>2018-08-22T02:39:49.000Z</published>
    <updated>2018-08-22T03:18:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Java 异常时定义在程序执行时，出现异常情况或问题的对象。其通常使用try….catch代码块来抛出以及捕捉。其中，需要注意的是，异常和错误在程序中是不同的；错误表示程序无法正常恢复，而异常，一般来说是可以处理的问题，例如除法中分母为0的情况。</p><p>异常代表着在程序执行过程中需要特别注意的一些异常的情况或者问题，对于这些问题，在它们出现之前进行处理是可能的。</p><h2 id="2-Java异常分类"><a href="#2-Java异常分类" class="headerlink" title="2.Java异常分类"></a>2.Java异常分类</h2><p>Java对异常的组织是比较简单的，其中所有的错误和异常都继承自Throwable。其中错误以及运行时异常都是未受检异常，这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的而或者引发了内部状态的改变导致的。那么这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止，让调用者对代码进行修正。如我上面例子的ArrayIndexOutOfBoundsException就是这类异常。</p><p>对于已检查异常，只要是Exception和其子类都是，除了特殊子类RuntimeException体系。 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。这样的问题都可以针对性的处理。如ClassNotFoundException就是这类异常。</p><p><img src="/image/built_in_exception.png" alt="Exception class hierarchy"></p><h2 id="3-实际中处理异常的原则"><a href="#3-实际中处理异常的原则" class="headerlink" title="3.实际中处理异常的原则"></a>3.实际中处理异常的原则</h2><ol><li>函数内容如果抛出已检查的异常，那么函数上必须要声明。否则必须在函数内用try-catch捕获，否则编译失败。</li><li>如果调用到了声明已检查异常的函数，要么try-catch要么throws，否则编译失败。</li><li>什么时候catch，什么时候throws 呢？功能内容可以解决，用catch。解决不了，用throws告诉调用者，由调用者解决 。</li><li>一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。内部又几个需要检测的异常，就抛几个异常，抛出几个，就catch几个。</li></ol><h2 id="4-参考资源"><a href="#4-参考资源" class="headerlink" title="4.参考资源"></a>4.参考资源</h2><ol><li><a href="https://blog.csdn.net/TimHeath/article/details/53504328" target="_blank" rel="noopener">Java异常介绍</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/index.html" target="_blank" rel="noopener">Java 异常处理的误区和经验总结</a></li><li><a href="https://www.developer.com/java/data/understanding-exception-handling-in-java.html" target="_blank" rel="noopener">Understanding Exception Handling in Java</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;Java 异常时定义在程序执行时，出现异常情况或问题的对象。其通常使用try….catch代码块来抛出以及捕捉。其中，需要注
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Cognition</title>
    <link href="http://yoursite.com/2018/08/03/Cognition/"/>
    <id>http://yoursite.com/2018/08/03/Cognition/</id>
    <published>2018-08-03T01:58:57.000Z</published>
    <updated>2018-09-10T01:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>人与人之间的差别从认知开始，又以认知结束，并且是一个不断自我强化的过程。</li><li>细致入微地观察，仔细全面地阅读，深刻痛苦地思考，平等热烈地讨论，积极高效地执行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;人与人之间的差别从认知开始，又以认知结束，并且是一个不断自我强化的过程。&lt;/li&gt;
&lt;li&gt;细致入微地观察，仔细全面地阅读，深刻痛苦地思考，平等热烈地讨论，积极高效地执行。&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/02/hello-world/"/>
    <id>http://yoursite.com/2018/08/02/hello-world/</id>
    <published>2018-08-02T09:40:45.000Z</published>
    <updated>2018-08-02T09:40:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
