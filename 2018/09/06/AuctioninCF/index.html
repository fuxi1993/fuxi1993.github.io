<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Auction in Cloud Foundry · FuXi's Daily</title><meta name="description" content="Auction in Cloud Foundry - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="FuXi's Daily"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fuxi1993" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Auction in Cloud Foundry</h1><div class="post-info">Sep 6, 2018</div><div class="post-content"><p>The auction package in this repository encodes the details behind Diego’s scheduling mechanism. There are two components in Diego that participate in auctions:</p>
<p>The Auctioneer is responsible for holding auctions whenever a Task or LongRunningProcess needs to be scheduled.<br>The Rep represents a Diego Cell in the auction by making bids and, if picked as the winner, running the Task or LongRunningProcess.<br>The Auctioneers run on the Diego “Brain” nodes, and there is only ever one active Auctioneer at a time (determined by acquiring a lock in Consul). There is one Rep running on every Diego Cell.</p>
<p>The Auctioneer communicates with Reps on all Cells when holding an auction.</p>
<h3 id="Overview-of-auction-runner"><a href="#Overview-of-auction-runner" class="headerlink" title="Overview of auction runner"></a>Overview of auction runner</h3><p>The auctionrunner package provides an ifrit process runner which consumes an incoming stream of requested auction work, batches it up, communicates with the Cell reps, picks winners, and then instructs the Cells to perform the work.<br>进入auction/auctionrunner/auction_runner.go可以发现auctionRunner的数据结构：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> auctionRunner <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger lager.Logger</span><br><span class="line"></span><br><span class="line">    delegate                      auctiontypes.AuctionRunnerDelegate</span><br><span class="line">    metricEmitter                 auctiontypes.AuctionMetricEmitterDelegate</span><br><span class="line">    batch                         *Batch</span><br><span class="line">    clock                         clock.Clock</span><br><span class="line">    workPool                      *workpool.WorkPool</span><br><span class="line">    startingContainerWeight       <span class="keyword">float64</span></span><br><span class="line">    startingContainerCountMaximum <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先看Batch这个数据结构，其在相同的包下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Batch <span class="keyword">struct</span> &#123;</span><br><span class="line">    lrpAuctions  []auctiontypes.LRPAuction</span><br><span class="line">    taskAuctions []auctiontypes.TaskAuction</span><br><span class="line">    lock         *sync.Mutex</span><br><span class="line">    HasWork      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    clock        clock.Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见其封装了一个两种任务的数组，并且通过sync.Mutex来达到线程安全，还使用了一个channel来进行io监听，每次生成一个任务时，都会调用claimToHaveWork方法，来向channel里添加一个值，这样在其他任务进入时，就可以检测任务是否已满，而不是一直等待，<strong><a href="http://yanyiwu.com/work/2014/11/08/golang-select-typical-usage.html" target="_blank" rel="noopener">golang的select典型用法</a></strong>，可见下面代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Batch)</span> <span class="title">AddLRPStarts</span><span class="params">(starts []auctioneer.LRPStartRequest)</span></span> &#123;</span><br><span class="line">    auctions := <span class="built_in">make</span>([]auctiontypes.LRPAuction, <span class="number">0</span>, <span class="built_in">len</span>(starts))</span><br><span class="line">    now := b.clock.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> starts &#123;</span><br><span class="line">        start := &amp;starts[i]</span><br><span class="line">        <span class="keyword">for</span> _, index := <span class="keyword">range</span> start.Indices &#123;</span><br><span class="line">            lrpKey := models.NewActualLRPKey(start.ProcessGuid, <span class="keyword">int32</span>(index), start.Domain)</span><br><span class="line">            auction := auctiontypes.NewLRPAuction(rep.NewLRP(lrpKey, start.Resource, start.PlacementConstraint), now)</span><br><span class="line">            auctions = <span class="built_in">append</span>(auctions, auction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b.lock.Lock()</span><br><span class="line">    b.lrpAuctions = <span class="built_in">append</span>(b.lrpAuctions, auctions...)</span><br><span class="line">    b.claimToHaveWork()</span><br><span class="line">    b.lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Batch)</span> <span class="title">claimToHaveWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> b.HasWork &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在回过头来看auctionRunner，其中的方法涉及到任务发送的代码是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *auctionRunner)</span> <span class="title">ScheduleLRPsForAuctions</span><span class="params">(lrpStarts []auctioneer.LRPStartRequest)</span></span> &#123;</span><br><span class="line">    a.batch.AddLRPStarts(lrpStarts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *auctionRunner)</span> <span class="title">ScheduleTasksForAuctions</span><span class="params">(tasks []auctioneer.TaskStartRequest)</span></span> &#123;</span><br><span class="line">    a.batch.AddTasks(tasks)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入核心方法Runner方法来查看执行的时候细节是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *auctionRunner)</span> <span class="title">Run</span><span class="params">(signals &lt;-<span class="keyword">chan</span> os.Signal, ready <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(ready)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hasWork <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    hasWork = a.batch.HasWork</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-hasWork:</span><br><span class="line">            logger := a.logger.Session(<span class="string">"auction"</span>)</span><br><span class="line"></span><br><span class="line">            logger.Info(<span class="string">"fetching-cell-reps"</span>)</span><br><span class="line">            clients, err := a.delegate.FetchCellReps()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logger.Error(<span class="string">"failed-to-fetch-reps"</span>, err)</span><br><span class="line">                time.Sleep(time.Second)</span><br><span class="line">                hasWork = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">                hasWork &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            logger.Info(<span class="string">"fetched-cell-reps"</span>, lager.Data&#123;<span class="string">"cell-reps-count"</span>: <span class="built_in">len</span>(clients)&#125;)</span><br><span class="line"></span><br><span class="line">            hasWork = a.batch.HasWork</span><br><span class="line"></span><br><span class="line">            logger.Info(<span class="string">"fetching-zone-state"</span>)</span><br><span class="line">            fetchStatesStartTime := time.Now()</span><br><span class="line">            zones := FetchStateAndBuildZones(logger, a.workPool, clients, a.metricEmitter)</span><br><span class="line">            fetchStateDuration := time.Since(fetchStatesStartTime)</span><br><span class="line">            err = a.metricEmitter.FetchStatesCompleted(fetchStateDuration)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logger.Error(<span class="string">"failed-sending-fetch-states-completed-metric"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cellCount := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> zone, cells := <span class="keyword">range</span> zones &#123;</span><br><span class="line">                logger.Info(<span class="string">"zone-state"</span>, lager.Data&#123;<span class="string">"zone"</span>: zone, <span class="string">"cell-count"</span>: <span class="built_in">len</span>(cells)&#125;)</span><br><span class="line">                cellCount += <span class="built_in">len</span>(cells)</span><br><span class="line">            &#125;</span><br><span class="line">            logger.Info(<span class="string">"fetched-zone-state"</span>, lager.Data&#123;</span><br><span class="line">                <span class="string">"cell-state-count"</span>:    cellCount,</span><br><span class="line">                <span class="string">"num-failed-requests"</span>: <span class="built_in">len</span>(clients) - cellCount,</span><br><span class="line">                <span class="string">"duration"</span>:            fetchStateDuration.String(),</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            logger.Info(<span class="string">"fetching-auctions"</span>)</span><br><span class="line">            lrpAuctions, taskAuctions := a.batch.DedupeAndDrain()</span><br><span class="line">            logger.Info(<span class="string">"fetched-auctions"</span>, lager.Data&#123;</span><br><span class="line">                <span class="string">"lrp-start-auctions"</span>: <span class="built_in">len</span>(lrpAuctions),</span><br><span class="line">                <span class="string">"task-auctions"</span>:      <span class="built_in">len</span>(taskAuctions),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(lrpAuctions) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(taskAuctions) == <span class="number">0</span> &#123;</span><br><span class="line">                logger.Info(<span class="string">"nothing-to-auction"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.Info(<span class="string">"scheduling"</span>)</span><br><span class="line">            auctionRequest := auctiontypes.AuctionRequest&#123;</span><br><span class="line">                LRPs:  lrpAuctions,</span><br><span class="line">                Tasks: taskAuctions,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scheduler := NewScheduler(a.workPool, zones, a.clock, logger, a.startingContainerWeight, a.startingContainerCountMaximum)</span><br><span class="line">            auctionResults := scheduler.Schedule(auctionRequest)</span><br><span class="line">            logger.Info(<span class="string">"scheduled"</span>, lager.Data&#123;</span><br><span class="line">                <span class="string">"successful-lrp-start-auctions"</span>: <span class="built_in">len</span>(auctionResults.SuccessfulLRPs),</span><br><span class="line">                <span class="string">"successful-task-auctions"</span>:      <span class="built_in">len</span>(auctionResults.SuccessfulTasks),</span><br><span class="line">                <span class="string">"failed-lrp-start-auctions"</span>:     <span class="built_in">len</span>(auctionResults.FailedLRPs),</span><br><span class="line">                <span class="string">"failed-task-auctions"</span>:          <span class="built_in">len</span>(auctionResults.FailedTasks),</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            a.metricEmitter.AuctionCompleted(auctionResults)</span><br><span class="line">            a.delegate.AuctionCompleted(auctionResults)</span><br><span class="line">        <span class="keyword">case</span> &lt;-signals:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这个方法通过for select循环来接收任务，并在循环体内处理任务，其中有一些涉及到其他模块的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetchStatesStartTime := time.Now()</span><br><span class="line">zones := FetchStateAndBuildZones(logger, a.workPool, clients, a.metricEmitter)</span><br><span class="line">fetchStateDuration := time.Since(fetchStatesStartTime)</span><br><span class="line">err = a.metricEmitter.FetchStatesCompleted(fetchStateDuration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">"failed-sending-fetch-states-completed-metric"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一段代码通过搜索可用zones来确定任务放置的位置；然后在调用Scheduler来进行任务调度：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">scheduler := NewScheduler(a.workPool, zones, a.clock, logger, a.startingContainerWeight, a.startingContainerCountMaximum)</span><br><span class="line">auctionResults := scheduler.Schedule(auctionRequest)</span><br><span class="line">logger.Info(<span class="string">"scheduled"</span>, lager.Data&#123;</span><br><span class="line">                <span class="string">"successful-lrp-start-auctions"</span>: <span class="built_in">len</span>(auctionResults.SuccessfulLRPs),</span><br><span class="line">                <span class="string">"successful-task-auctions"</span>:      <span class="built_in">len</span>(auctionResults.SuccessfulTasks),</span><br><span class="line">                <span class="string">"failed-lrp-start-auctions"</span>:     <span class="built_in">len</span>(auctionResults.FailedLRPs),</span><br><span class="line">                <span class="string">"failed-task-auctions"</span>:          <span class="built_in">len</span>(auctionResults.FailedTasks),</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">a.metricEmitter.AuctionCompleted(auctionResults)</span><br><span class="line">a.delegate.AuctionCompleted(auctionResults)</span><br></pre></td></tr></table></figure></p>
<h4 id="涉及到auction-schedule的代码"><a href="#涉及到auction-schedule的代码" class="headerlink" title="涉及到auction schedule的代码"></a>涉及到auction schedule的代码</h4><p>Scheduler的数据结构：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheduler <span class="keyword">struct</span> &#123;</span><br><span class="line">    workPool                      *workpool.WorkPool</span><br><span class="line">    zones                         <span class="keyword">map</span>[<span class="keyword">string</span>]Zone</span><br><span class="line">    clock                         clock.Clock</span><br><span class="line">    logger                        lager.Logger</span><br><span class="line">    startingContainerWeight       <span class="keyword">float64</span></span><br><span class="line">    startingContainerCountMaximum <span class="keyword">int</span> <span class="comment">// &lt;=0 means no limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看Schedule的方法介绍：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Schedule takes in a set of job requests (LRP start auctions and task starts) and</span></span><br><span class="line"><span class="comment">assigns the work to available cells according to the diego scoring algorithm. The</span></span><br><span class="line"><span class="comment">scheduler is single-threaded.  It determines scheduling of jobs one at a time so</span></span><br><span class="line"><span class="comment">that each calculation reflects available resources correctly.  It commits the</span></span><br><span class="line"><span class="comment">work in batches at the end, for better network performance.  Schedule returns</span></span><br><span class="line"><span class="comment">AuctionResults, indicating the success or failure of each requested job.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>在Schedule方法中，通过对任务进行排序和分割，然后分别调用schedule.scheduleLRPAuction和schedule.scheduleTaskAuction方法来进行调度执行，方法详情如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">scheduleLRPAuction</span><span class="params">(lrpAuction *auctiontypes.LRPAuction)</span> <span class="params">(*auctiontypes.LRPAuction, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> winnerCell *Cell</span><br><span class="line">    winnerScore := <span class="number">1e20</span></span><br><span class="line"></span><br><span class="line">    zones := accumulateZonesByInstances(s.zones, lrpAuction.ProcessGuid)</span><br><span class="line"></span><br><span class="line">    filteredZones, err := filterZones(zones, lrpAuction)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sortedZones := sortZonesByInstances(filteredZones)</span><br><span class="line">    problems := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;<span class="string">"disk"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="string">"memory"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="string">"containers"</span>: <span class="keyword">struct</span>&#123;&#125;&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    s.logger.Info(<span class="string">"schedule-lrp-auction"</span>, lager.Data&#123;<span class="string">"problems"</span>: problems&#125;)</span><br><span class="line">    <span class="keyword">for</span> zoneIndex, lrpByZone := <span class="keyword">range</span> sortedZones &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cell := <span class="keyword">range</span> lrpByZone.zone &#123;</span><br><span class="line">            score, err := cell.ScoreForLRP(&amp;lrpAuction.LRP, s.startingContainerWeight)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                removeNonApplicableProblems(problems, err)</span><br><span class="line">                s.logger.Info(<span class="string">"schedule-lrp-auction-after-error"</span>, lager.Data&#123;<span class="string">"problems"</span>: problems, <span class="string">"error"</span>: err&#125;)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> score &lt; winnerScore &#123;</span><br><span class="line">                winnerScore = score</span><br><span class="line">                winnerCell = cell</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (not last zone) &amp;&amp; (this zone has the same # of instances as the next sorted zone)</span></span><br><span class="line">        <span class="comment">// acts as a tie breaker</span></span><br><span class="line">        <span class="keyword">if</span> zoneIndex+<span class="number">1</span> &lt; <span class="built_in">len</span>(sortedZones) &amp;&amp;</span><br><span class="line">            lrpByZone.instances == sortedZones[zoneIndex+<span class="number">1</span>].instances &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> winnerCell != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> winnerCell == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, &amp;rep.InsufficientResourcesError&#123;Problems: problems&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = winnerCell.ReserveLRP(&amp;lrpAuction.LRP)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.logger.Error(<span class="string">"lrp-failed-to-reserve-cell"</span>, err, lager.Data&#123;<span class="string">"cell-guid"</span>: winnerCell.Guid, <span class="string">"lrp-guid"</span>: lrpAuction.Identifier()&#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    winningAuction := lrpAuction.Copy()</span><br><span class="line">    winningAuction.Winner = winnerCell.Guid</span><br><span class="line">    <span class="keyword">return</span> &amp;winningAuction, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以首先通过对每个zone，在对每个zone中的每个cell进行查找，已找到每个zone对应的instance的个数(这里的processGuid不是很清楚，需要后面确定)，然后进行filter，filterZones方法的代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filterZones</span><span class="params">(zones []lrpByZone, lrpAuction *auctiontypes.LRPAuction)</span> <span class="params">([]lrpByZone, error)</span></span> &#123;</span><br><span class="line">    filteredZones := []lrpByZone&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> zoneError error</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, lrpZone := <span class="keyword">range</span> zones &#123;</span><br><span class="line">        cells, err := lrpZone.zone.filterCells(lrpAuction.PlacementConstraint)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            _, isZoneErrorPlacementTagMismatchError := zoneError.(auctiontypes.PlacementTagMismatchError)</span><br><span class="line">            _, isErrPlacementTagMismatchError := err.(auctiontypes.PlacementTagMismatchError)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isZoneErrorPlacementTagMismatchError ||</span><br><span class="line">                (zoneError == auctiontypes.ErrorVolumeDriverMismatch &amp;&amp; isErrPlacementTagMismatchError) ||</span><br><span class="line">                zoneError == auctiontypes.ErrorCellMismatch || zoneError == <span class="literal">nil</span> &#123;</span><br><span class="line">                zoneError = err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filteredZone := lrpByZone&#123;</span><br><span class="line">            zone:      Zone(cells),</span><br><span class="line">            instances: lrpZone.instances,</span><br><span class="line">        &#125;</span><br><span class="line">        filteredZones = <span class="built_in">append</span>(filteredZones, filteredZone)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(filteredZones) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, zoneError</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filteredZones, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中对每个zone中的cell进行了帅选，其中帅选的条件包括Rootfs, VolumeDriver, PlacementTags, 已选择合适的cell进行实例的启动操作：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Zone)</span> <span class="title">filterCells</span><span class="params">(pc rep.PlacementConstraint)</span> <span class="params">([]*Cell, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cells = <span class="built_in">make</span>([]*Cell, <span class="number">0</span>, <span class="built_in">len</span>(*z))</span><br><span class="line">    err := auctiontypes.ErrorCellMismatch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, cell := <span class="keyword">range</span> *z &#123;</span><br><span class="line">        <span class="keyword">if</span> cell.MatchRootFS(pc.RootFs) &#123;</span><br><span class="line">            <span class="keyword">if</span> err == auctiontypes.ErrorCellMismatch &#123;</span><br><span class="line">                err = auctiontypes.ErrorVolumeDriverMismatch</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cell.MatchVolumeDrivers(pc.VolumeDrivers) &#123;</span><br><span class="line">                <span class="keyword">if</span> err == auctiontypes.ErrorVolumeDriverMismatch &#123;</span><br><span class="line">                    err = auctiontypes.NewPlacementTagMismatchError(pc.PlacementTags)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cell.MatchPlacementTags(pc.PlacementTags) &#123;</span><br><span class="line">                    err = <span class="literal">nil</span></span><br><span class="line">                    cells = <span class="built_in">append</span>(cells, cell)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cells, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在完成帅选的过程后，schedule对选择的zones进行了排序，然后开始对zones中的cell进行评分，已达到选择最优的cell的目的，这个过程是贪心的，即在这个zone中完成了最优的cell的帅选，就break，然后执行winnerCell.ReserveLRP(&amp;lrpAuction.LRP)来确定。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cell)</span> <span class="title">ReserveLRP</span><span class="params">(lrp *rep.LRP)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := c.state.ResourceMatch(&amp;lrp.Resource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.state.AddLRP(lrp)</span><br><span class="line">    c.workToCommit.LRPs = <span class="built_in">append</span>(c.workToCommit.LRPs, *lrp)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再看Cell的数据结构，基本可以了解其对其他组件的交互逻辑：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cell <span class="keyword">struct</span> &#123;</span><br><span class="line">    logger lager.Logger</span><br><span class="line">    Guid   <span class="keyword">string</span></span><br><span class="line">    client rep.Client</span><br><span class="line">    state  rep.CellState</span><br><span class="line"></span><br><span class="line">    workToCommit rep.Work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们再看schedule的提交任务的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failedWorks := s.commitCells()</span><br></pre></td></tr></table></figure></p>
<p>这个方法的实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scheduler)</span> <span class="title">commitCells</span><span class="params">()</span> []<span class="title">rep</span>.<span class="title">Work</span></span> &#123;</span><br><span class="line">    wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, cells := <span class="keyword">range</span> s.zones &#123;</span><br><span class="line">        wg.Add(<span class="built_in">len</span>(cells))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock := &amp;sync.Mutex&#123;&#125;</span><br><span class="line">    failedWorks := []rep.Work&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, cells := <span class="keyword">range</span> s.zones &#123;</span><br><span class="line">        <span class="keyword">for</span> _, cell := <span class="keyword">range</span> cells &#123;</span><br><span class="line">            cell := cell</span><br><span class="line">            s.workPool.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                failedWork := cell.Commit()</span><br><span class="line"></span><br><span class="line">                lock.Lock()</span><br><span class="line">                failedWorks = <span class="built_in">append</span>(failedWorks, failedWork)</span><br><span class="line">                lock.Unlock()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> failedWorks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码很有意思，可以分析一下，先说说WaitGroup的用途：它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成。</p>
<p>WaitGroup总共有三个方法：Add(delta int),Done(),Wait()。简单的说一下这三个方法的作用。</p>
<p>Add:添加或者减少等待goroutine的数量</p>
<p>Done:相当于Add(-1)</p>
<p>Wait:执行阻塞，直到所有的WaitGroup数量变成0</p>
<p><br> 所以上面这段代码通过sync.waitGroup来讲需要存放实例的cell的数量入其中，然后调用workPool协程池将任务提交到其中，其中submit函数中defer wg.Done()表示每当完成一个任务就减一。在最后面，执行wg.Wait（）阻塞，直到队列中所有的任务结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cell)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">rep</span>.<span class="title">Work</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(c.workToCommit.LRPs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(c.workToCommit.Tasks) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rep.Work&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    failedWork, err := c.client.Perform(c.logger, c.workToCommit)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.logger.Error(<span class="string">"failed-to-commit"</span>, err, lager.Data&#123;<span class="string">"cell-guid"</span>: c.Guid&#125;)</span><br><span class="line">        <span class="comment">//an error may indicate partial failure</span></span><br><span class="line">        <span class="comment">//in this case we don't reschedule work in order to make sure we don't</span></span><br><span class="line">        <span class="comment">//create duplicates of things -- we'll let the converger figure things out for us later</span></span><br><span class="line">        <span class="keyword">return</span> rep.Work&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> failedWork</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中Cell.client.Perform来执行真是的任务。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/06/BBS in CloudFoundry/" class="prev">PREV</a><a href="/2018/09/06/RepCF/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>