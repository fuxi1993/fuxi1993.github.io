<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Rep in Cloud Foundry · FuXi's Daily</title><meta name="description" content="Rep in Cloud Foundry - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="FuXi's Daily"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fuxi1993" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Rep in Cloud Foundry</h1><div class="post-info">Sep 6, 2018</div><div class="post-content"><p>The Rep bids on tasks and schedules them on an associated Executor.Rep是Diego中真正完成lrp和tasks的任务的模块，其也是通过http来接收了处理相关的请求。</p>
<h3 id="routes-of-rep"><a href="#routes-of-rep" class="headerlink" title="routes of rep"></a>routes of rep</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRoutes</span><span class="params">(secure <span class="keyword">bool</span>)</span> <span class="title">rata</span>.<span class="title">Routes</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> routes rata.Routes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> secure &#123;</span><br><span class="line">        routes = <span class="built_in">append</span>(routes,</span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/state"</span>, Method: <span class="string">"GET"</span>, Name: StateRoute&#125;,</span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/work"</span>, Method: <span class="string">"POST"</span>, Name: PerformRoute&#125;,</span><br><span class="line"></span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/v1/lrps/:process_guid/instances/:instance_guid/stop"</span>, Method: <span class="string">"POST"</span>, Name: StopLRPInstanceRoute&#125;,</span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/v1/tasks/:task_guid/cancel"</span>, Method: <span class="string">"POST"</span>, Name: CancelTaskRoute&#125;,</span><br><span class="line"></span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/sim/reset"</span>, Method: <span class="string">"POST"</span>, Name: Sim_ResetRoute&#125;,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !secure &#123;</span><br><span class="line">        routes = <span class="built_in">append</span>(routes,</span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/ping"</span>, Method: <span class="string">"GET"</span>, Name: PingRoute&#125;,</span><br><span class="line">            rata.Route&#123;Path: <span class="string">"/evacuate"</span>, Method: <span class="string">"POST"</span>, Name: EvacuateRoute&#125;,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> routes</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RoutesInsecure = NewRoutes(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> RoutesSecure = NewRoutes(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> Routes = <span class="built_in">append</span>(RoutesInsecure, RoutesSecure...)</span><br></pre></td></tr></table></figure>
<p>然后在rep/handlers/handlers.go文件中定义了每个route对应的http handler:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    localCellClient auctioncellrep.AuctionCellClient,</span></span></span><br><span class="line"><span class="function"><span class="params">    executorClient executor.Client,</span></span></span><br><span class="line"><span class="function"><span class="params">    evacuatable evacuation_context.Evacuatable,</span></span></span><br><span class="line"><span class="function"><span class="params">    logger lager.Logger,</span></span></span><br><span class="line"><span class="function"><span class="params">    secure <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">rata</span>.<span class="title">Handlers</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    handlers := rata.Handlers&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> secure &#123;</span><br><span class="line">        stateHandler := &amp;state&#123;rep: localCellClient&#125;</span><br><span class="line">        performHandler := &amp;perform&#123;rep: localCellClient&#125;</span><br><span class="line">        resetHandler := &amp;reset&#123;rep: localCellClient&#125;</span><br><span class="line">        stopLrpHandler := NewStopLRPInstanceHandler(executorClient)</span><br><span class="line">        cancelTaskHandler := NewCancelTaskHandler(executorClient)</span><br><span class="line"></span><br><span class="line">        handlers[rep.StateRoute] = logWrap(stateHandler.ServeHTTP, logger)</span><br><span class="line">        handlers[rep.PerformRoute] = logWrap(performHandler.ServeHTTP, logger)</span><br><span class="line">        handlers[rep.Sim_ResetRoute] = logWrap(resetHandler.ServeHTTP, logger)</span><br><span class="line"></span><br><span class="line">        handlers[rep.StopLRPInstanceRoute] = logWrap(stopLrpHandler.ServeHTTP, logger)</span><br><span class="line">        handlers[rep.CancelTaskRoute] = logWrap(cancelTaskHandler.ServeHTTP, logger)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pingHandler := NewPingHandler()</span><br><span class="line">        evacuationHandler := NewEvacuationHandler(evacuatable)</span><br><span class="line"></span><br><span class="line">        handlers[rep.PingRoute] = logWrap(pingHandler.ServeHTTP, logger)</span><br><span class="line">        handlers[rep.EvacuateRoute] = logWrap(evacuationHandler.ServeHTTP, logger)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="handlers-of-route"><a href="#handlers-of-route" class="headerlink" title="handlers of route"></a>handlers of route</h3><p>在每一个handler中，存在一个非常重要的数据结构CellState :<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CellState <span class="keyword">struct</span> &#123;</span><br><span class="line">    RootFSProviders        RootFSProviders</span><br><span class="line">    AvailableResources     Resources</span><br><span class="line">    TotalResources         Resources</span><br><span class="line">    LRPs                   []LRP</span><br><span class="line">    Tasks                  []Task</span><br><span class="line">    StartingContainerCount <span class="keyword">int</span></span><br><span class="line">    Zone                   <span class="keyword">string</span></span><br><span class="line">    Evacuating             <span class="keyword">bool</span></span><br><span class="line">    VolumeDrivers          []<span class="keyword">string</span></span><br><span class="line">    PlacementTags          []<span class="keyword">string</span></span><br><span class="line">    OptionalPlacementTags  []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们在一个一个看每个handler的业务逻辑，从上面的代码可以看出，每个hanlder都进行了封装，stateHandler实际上就是实现了一个接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AuctionCellClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    State(logger lager.Logger) (rep.CellState, <span class="keyword">bool</span>, error)</span><br><span class="line">    Perform(logger lager.Logger, work rep.Work) (rep.Work, error)</span><br><span class="line">    Reset() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AuctionCellRep <span class="keyword">struct</span> &#123;</span><br><span class="line">    cellID                <span class="keyword">string</span></span><br><span class="line">    stackPathMap          rep.StackPathMap</span><br><span class="line">    rootFSProviders       rep.RootFSProviders</span><br><span class="line">    stack                 <span class="keyword">string</span></span><br><span class="line">    zone                  <span class="keyword">string</span></span><br><span class="line">    generateInstanceGuid  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">client</span>                <span class="title">executor</span>.<span class="title">Client</span></span></span><br><span class="line"><span class="function">    <span class="title">evacuationReporter</span>    <span class="title">evacuation_context</span>.<span class="title">EvacuationReporter</span></span></span><br><span class="line"><span class="function">    <span class="title">placementTags</span>         []<span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">optionalPlacementTags</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>因为任何实现了这三个方法的对象都算是继承了AuctionCellClient的接口，进入当前文件的State, Perform, Reset方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State currently does not return tasks or lrp rootfs, because the</span></span><br><span class="line"><span class="comment">// auctioneer currently does not need them.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AuctionCellRep)</span> <span class="title">State</span><span class="params">(logger lager.Logger)</span> <span class="params">(rep.CellState, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    logger = logger.Session(<span class="string">"auction-state"</span>)</span><br><span class="line">    logger.Info(<span class="string">"providing"</span>)</span><br><span class="line"></span><br><span class="line">    containers, err := a.client.ListContainers(logger)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-to-fetch-containers"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> rep.CellState&#123;&#125;, <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totalResources, err := a.client.TotalResources(logger)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-to-get-total-resources"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> rep.CellState&#123;&#125;, <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    availableResources, err := a.client.RemainingResources(logger)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-to-get-remaining-resource"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> rep.CellState&#123;&#125;, <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    volumeDrivers, err := a.client.VolumeDrivers(logger)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-to-get-volume-drivers"</span>, err)</span><br><span class="line">        <span class="keyword">return</span> rep.CellState&#123;&#125;, <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> key *models.ActualLRPKey</span><br><span class="line">    <span class="keyword">var</span> keyErr error</span><br><span class="line">    lrps := []rep.LRP&#123;&#125;</span><br><span class="line">    tasks := []rep.Task&#123;&#125;</span><br><span class="line">    startingContainerCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> containers &#123;</span><br><span class="line">        container := &amp;containers[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> containerIsStarting(container) &#123;</span><br><span class="line">            startingContainerCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> container.Tags == <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Error(<span class="string">"failed-to-extract-container-tags"</span>, <span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resource := rep.Resource&#123;MemoryMB: <span class="keyword">int32</span>(container.MemoryMB), DiskMB: <span class="keyword">int32</span>(container.DiskMB)&#125;</span><br><span class="line">        placementConstraint := rep.PlacementConstraint&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> container.Tags[rep.LifecycleTag] &#123;</span><br><span class="line">        <span class="keyword">case</span> rep.LRPLifecycle:</span><br><span class="line">            key, keyErr = rep.ActualLRPKeyFromTags(container.Tags)</span><br><span class="line">            <span class="keyword">if</span> keyErr != <span class="literal">nil</span> &#123;</span><br><span class="line">                logger.Error(<span class="string">"failed-to-extract-key"</span>, keyErr)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            lrps = <span class="built_in">append</span>(lrps, rep.NewLRP(*key, resource, placementConstraint))</span><br><span class="line">        <span class="keyword">case</span> rep.TaskLifecycle:</span><br><span class="line">            domain := container.Tags[rep.DomainTag]</span><br><span class="line">            tasks = <span class="built_in">append</span>(tasks, rep.NewTask(container.Guid, domain, resource, placementConstraint))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state := rep.NewCellState(</span><br><span class="line">        a.rootFSProviders,</span><br><span class="line">        a.convertResources(availableResources),</span><br><span class="line">        a.convertResources(totalResources),</span><br><span class="line">        lrps,</span><br><span class="line">        tasks,</span><br><span class="line">        a.zone,</span><br><span class="line">        startingContainerCount,</span><br><span class="line">        a.evacuationReporter.Evacuating(),</span><br><span class="line">        volumeDrivers,</span><br><span class="line">        a.placementTags,</span><br><span class="line">        a.optionalPlacementTags,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    healthy := a.client.Healthy(logger)</span><br><span class="line">    <span class="keyword">if</span> !healthy &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-garden-health-check"</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">"provided"</span>, lager.Data&#123;</span><br><span class="line">        <span class="string">"available-resources"</span>: state.AvailableResources,</span><br><span class="line">        <span class="string">"total-resources"</span>:     state.TotalResources,</span><br><span class="line">        <span class="string">"num-lrps"</span>:            <span class="built_in">len</span>(state.LRPs),</span><br><span class="line">        <span class="string">"zone"</span>:                state.Zone,</span><br><span class="line">        <span class="string">"evacuating"</span>:          state.Evacuating,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state, healthy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从state中可以看出，其调用executor.client来获取当前系统中的container, 总资源，剩余资源，最后讲得到的信息形成LRP和tasks，并放在state上返回，即可得到当前系统中的所有相关信息。</p>
<p><br>下面在看接口Perform方法的实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AuctionCellRep)</span> <span class="title">Perform</span><span class="params">(logger lager.Logger, work rep.Work)</span> <span class="params">(rep.Work, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> failedWork = rep.Work&#123;&#125;</span><br><span class="line"></span><br><span class="line">    logger = logger.Session(<span class="string">"auction-work"</span>, lager.Data&#123;</span><br><span class="line">        <span class="string">"lrp-starts"</span>: <span class="built_in">len</span>(work.LRPs),</span><br><span class="line">        <span class="string">"tasks"</span>:      <span class="built_in">len</span>(work.Tasks),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a.evacuationReporter.Evacuating() &#123;</span><br><span class="line">        <span class="keyword">return</span> work, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(work.LRPs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lrpLogger := logger.Session(<span class="string">"lrp-allocate-instances"</span>)</span><br><span class="line"></span><br><span class="line">        requests, lrpMap, untranslatedLRPs := a.lrpsToAllocationRequest(work.LRPs)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(untranslatedLRPs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            lrpLogger.Info(<span class="string">"failed-to-translate-lrps-to-containers"</span>, lager.Data&#123;<span class="string">"num-failed-to-translate"</span>: <span class="built_in">len</span>(untranslatedLRPs)&#125;)</span><br><span class="line">            failedWork.LRPs = untranslatedLRPs</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lrpLogger.Info(<span class="string">"requesting-container-allocation"</span>, lager.Data&#123;<span class="string">"num-requesting-allocation"</span>: <span class="built_in">len</span>(requests)&#125;)</span><br><span class="line">        failures, err := a.client.AllocateContainers(logger, requests)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            lrpLogger.Error(<span class="string">"failed-requesting-container-allocation"</span>, err)</span><br><span class="line">            failedWork.LRPs = work.LRPs</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lrpLogger.Info(<span class="string">"succeeded-requesting-container-allocation"</span>, lager.Data&#123;<span class="string">"num-failed-to-allocate"</span>: <span class="built_in">len</span>(failures)&#125;)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> failures &#123;</span><br><span class="line">                failure := &amp;failures[i]</span><br><span class="line">                lrpLogger.Error(<span class="string">"container-allocation-failure"</span>, failure, lager.Data&#123;<span class="string">"failed-request"</span>: &amp;failure.AllocationRequest&#125;)</span><br><span class="line">                <span class="keyword">if</span> lrp, found := lrpMap[failure.Guid]; found &#123;</span><br><span class="line">                    failedWork.LRPs = <span class="built_in">append</span>(failedWork.LRPs, *lrp)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(work.Tasks) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        taskLogger := logger.Session(<span class="string">"task-allocate-instances"</span>)</span><br><span class="line"></span><br><span class="line">        requests, taskMap, failedTasks := a.tasksToAllocationRequests(work.Tasks)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(failedTasks) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            taskLogger.Info(<span class="string">"failed-to-translate-tasks-to-containers"</span>, lager.Data&#123;<span class="string">"num-failed-to-translate"</span>: <span class="built_in">len</span>(failedTasks)&#125;)</span><br><span class="line">            failedWork.Tasks = failedTasks</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        taskLogger.Info(<span class="string">"requesting-container-allocation"</span>, lager.Data&#123;<span class="string">"num-requesting-allocation"</span>: <span class="built_in">len</span>(requests)&#125;)</span><br><span class="line">        failures, err := a.client.AllocateContainers(logger, requests)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            taskLogger.Error(<span class="string">"failed-requesting-container-allocation"</span>, err)</span><br><span class="line">            failedWork.Tasks = work.Tasks</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            taskLogger.Info(<span class="string">"succeeded-requesting-container-allocation"</span>, lager.Data&#123;<span class="string">"num-failed-to-allocate"</span>: <span class="built_in">len</span>(failures)&#125;)</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> failures &#123;</span><br><span class="line">                failure := &amp;failures[i]</span><br><span class="line">                taskLogger.Error(<span class="string">"container-allocation-failure"</span>, failure, lager.Data&#123;<span class="string">"failed-request"</span>: &amp;failure.AllocationRequest&#125;)</span><br><span class="line">                <span class="keyword">if</span> task, found := taskMap[failure.Guid]; found &#123;</span><br><span class="line">                    failedWork.Tasks = <span class="built_in">append</span>(failedWork.Tasks, *task)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> failedWork, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中可见，通过传入的work(rep.Work)，代码将其分成了两类任务，lrp和tasks，关于lrp任务，首先调用AuctionCellRep.lrpsToAllocationRequest()来转化成requests,然后调用a.client.AllocateContainers(requests)来处理请求,并对后面的失败的任务进行了一个重启的过程。<br><br>关于tasks，处理的逻辑差不多，最后返回的是失败的任务。<br>关于reset的代码很简单，如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AuctionCellRep)</span> <span class="title">Reset</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"not-a-simulation-rep"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="另一类处理方式"><a href="#另一类处理方式" class="headerlink" title="另一类处理方式"></a>另一类处理方式</h3><p>对于stopLrpHandler和cancelTaskHandler句柄，分别调用了executor的相关实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StopLRPInstanceHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    client executor.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStopLRPInstanceHandler</span><span class="params">(client executor.Client)</span> *<span class="title">StopLRPInstanceHandler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StopLRPInstanceHandler&#123;</span><br><span class="line">        client: client,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h StopLRPInstanceHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request, logger lager.Logger)</span></span> &#123;</span><br><span class="line">    processGuid := r.FormValue(<span class="string">":process_guid"</span>)</span><br><span class="line">    instanceGuid := r.FormValue(<span class="string">":instance_guid"</span>)</span><br><span class="line"></span><br><span class="line">    logger = logger.Session(<span class="string">"handling-stop-lrp-instance"</span>, lager.Data&#123;</span><br><span class="line">        <span class="string">"process-guid"</span>:  processGuid,</span><br><span class="line">        <span class="string">"instance-guid"</span>: instanceGuid,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> processGuid == <span class="string">""</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"missing-process-guid"</span>, errors.New(<span class="string">"process_guid missing from request"</span>))</span><br><span class="line">        w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> instanceGuid == <span class="string">""</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"missing-instance-guid"</span>, errors.New(<span class="string">"instance_guid missing from request"</span>))</span><br><span class="line">        w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := h.client.StopContainer(logger, rep.LRPContainerGuid(processGuid, instanceGuid))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">        logger.Error(<span class="string">"failed-to-stop-container"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.WriteHeader(http.StatusAccepted)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，其调用了h.client.StopContainer的方法来实现了功能该需求。另外一个也是类似，就不一一列举了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/06/auctioineerCP/" class="prev">PREV</a><a href="/2018/09/05/what-s-thread-safe/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>