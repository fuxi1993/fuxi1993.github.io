<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> BBS in CloudFoundry · FuXi's Daily</title><meta name="description" content="BBS in CloudFoundry - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="FuXi's Daily"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/fuxi1993" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">BBS in CloudFoundry</h1><div class="post-info">Sep 6, 2018</div><div class="post-content"><p>Diego’s Bulletin Board System (BBS) is the central data store and orchestrator of a Diego cluster. It communicates via protocol-buffer-encoded RPC-style calls over HTTP.</p>
<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><h3 id="Routes-of-BBS"><a href="#Routes-of-BBS" class="headerlink" title="Routes of BBS"></a>Routes of BBS</h3><p>CloudFoundry中是使用rata这个package来处路由信息，rata主要提供了routes, a router and a requestGenerator.在routes.go文件中，路由定义如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Routes = rata.Routes&#123;</span><br><span class="line">    <span class="comment">// Desired LRPs</span></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrp_scheduling_infos/list"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPSchedulingInfosRoute&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrps/list.r2"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPsRoute&#125;,</span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrps/get_by_process_guid.r2"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPByProcessGuidRoute&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrps/list.r1"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPsRoute_r1&#125;,                            <span class="comment">// Deprecated</span></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrps/get_by_process_guid.r1"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPByProcessGuidRoute_r1&#125;, <span class="comment">// Deprecated</span></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrps/list"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPsRoute_r0&#125;,                               <span class="comment">// Deprecated</span></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrps/get_by_process_guid"</span>, Method: <span class="string">"POST"</span>, Name: DesiredLRPByProcessGuidRoute_r0&#125;,    <span class="comment">// Deprecated</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Desire LPR Lifecycle</span></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrp/desire.r2"</span>, Method: <span class="string">"POST"</span>, Name: DesireDesiredLRPRoute&#125;,</span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrp/desire.r1"</span>, Method: <span class="string">"POST"</span>, Name: DesireDesiredLRPRoute_r1&#125;, <span class="comment">// Deprecated</span></span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrp/update"</span>, Method: <span class="string">"POST"</span>, Name: UpdateDesiredLRPRoute&#125;,</span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrp/remove"</span>, Method: <span class="string">"POST"</span>, Name: RemoveDesiredLRPRoute&#125;,</span><br><span class="line">    &#123;Path: <span class="string">"/v1/desired_lrp/desire"</span>, Method: <span class="string">"POST"</span>, Name: DesireDesiredLRPRoute_r0&#125;, <span class="comment">// Deprecated</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的路由主要显示了desired_lrp的请求，其他类型的请求大概差不多。<br>在server端，需要创建对应的http handler,在handlers/handlers.go中定义了相关的内容：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actions := rata.Handlers&#123;</span><br><span class="line">        <span class="comment">// Desired LRPs</span></span><br><span class="line">        bbs.DesiredLRPsRoute:               route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPs))),</span><br><span class="line">        bbs.DesiredLRPByProcessGuidRoute:   route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPByProcessGuid))),</span><br><span class="line">        bbs.DesiredLRPSchedulingInfosRoute: route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPSchedulingInfos))),</span><br><span class="line">        bbs.DesireDesiredLRPRoute:          route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesireDesiredLRP))),</span><br><span class="line">        bbs.UpdateDesiredLRPRoute:          route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.UpdateDesiredLRP))),</span><br><span class="line">        bbs.RemoveDesiredLRPRoute:          route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.RemoveDesiredLRP))),</span><br><span class="line"></span><br><span class="line">        bbs.DesiredLRPsRoute_r0:             route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPs_r0))),</span><br><span class="line">        bbs.DesiredLRPsRoute_r1:             route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPs_r1))),</span><br><span class="line">        bbs.DesiredLRPByProcessGuidRoute_r0: route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPByProcessGuid_r0))),</span><br><span class="line">        bbs.DesiredLRPByProcessGuidRoute_r1: route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesiredLRPByProcessGuid_r1))),</span><br><span class="line">        bbs.DesireDesiredLRPRoute_r0:        route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesireDesiredLRP_r0))),</span><br><span class="line">        bbs.DesireDesiredLRPRoute_r1:        route(emitter.RecordLatency(middleware.LogWrap(logger, accessLogger, desiredLRPHandler.DesireDesiredLRP_r1))),</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在每一个route对应的handler中都做了相应的封装(log, 超时设置等)，实际处理的为desiredLRPHandler.***。</p>
<p>在这个文件中对应处理了每一个route的请求，也是实际的业务代码实现的地方。</p>
<h3 id="An-exampler-DesiredLRPHandler"><a href="#An-exampler-DesiredLRPHandler" class="headerlink" title="An exampler: DesiredLRPHandler"></a>An exampler: DesiredLRPHandler</h3><p>在转到对应的desired_lrp_handlers.go文件中可以看到DesiredLRPHandler的数据结构：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DesiredLRPHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    desiredLRPDB       db.DesiredLRPDB</span><br><span class="line">    actualLRPDB        db.ActualLRPDB</span><br><span class="line">    desiredHub         events.Hub</span><br><span class="line">    actualHub          events.Hub</span><br><span class="line">    auctioneerClient   auctioneer.Client</span><br><span class="line">    repClientFactory   rep.ClientFactory</span><br><span class="line">    serviceClient      serviceclient.ServiceClient</span><br><span class="line">    updateWorkersCount <span class="keyword">int</span></span><br><span class="line">    exitChan           <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出这个处理句柄中主要有这几类参数：数据库参数，事件处理中心，auctionerr.Client参数，Diego中的cell中的rep的Client，还有一个exitChan管道。<br></p>
<h4 id="涉及数据库-bbs-db-的更新"><a href="#涉及数据库-bbs-db-的更新" class="headerlink" title="涉及数据库(bbs db)的更新"></a>涉及数据库(bbs db)的更新</h4><p>其中很多handler方法是直接操作数据库获取相应的信息，以DesiredLRPs为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DesiredLRPHandler)</span> <span class="title">DesiredLRPs</span><span class="params">(logger lager.Logger, w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    logger = logger.Session(<span class="string">"desired-lrps"</span>)</span><br><span class="line"></span><br><span class="line">    request := &amp;models.DesiredLRPsRequest&#123;&#125;</span><br><span class="line">    response := &amp;models.DesiredLRPsResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">    err = parseRequest(logger, req, request)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        filter := models.DesiredLRPFilter&#123;Domain: request.Domain, ProcessGuids: request.ProcessGuids&#125;</span><br><span class="line">        response.DesiredLrps, err = h.desiredLRPDB.DesiredLRPs(logger, filter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.Error = models.ConvertError(err)</span><br><span class="line">    writeResponse(w, response)</span><br><span class="line">    exitIfUnrecoverable(logger, h.exitChan, response.Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为在bbs中使用的是protocol buffers数据交换格式，以上面的方法为例，在models/desired_lrp_requests.proto中定义了请求传输的数据格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message DesiredLRPsResponse &#123;</span><br><span class="line">  optional Error error = 1;</span><br><span class="line">  repeated DesiredLRP desired_lrps = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DesiredLRPsRequest &#123;</span><br><span class="line">  optional string domain = 1;</span><br><span class="line">  repeated string process_guids = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这个handler方法通过将请求解析，验证，然后调用handler.desiredLRPDB中的方法来获取相应结果，然后调用writeResponse(w, response)来将结果写入到返回w http.ResponseWriter。</p>
<h4 id="涉及到events-Hub的方法调用"><a href="#涉及到events-Hub的方法调用" class="headerlink" title="涉及到events.Hub的方法调用"></a>涉及到events.Hub的方法调用</h4><p>关于LRP创建，更新，其中的方法调用了events.hub协程来处理这类的事件(我估计因为涉及到调度相关的策略，所以需要一个事件处理中心来解决这类问题)，以DesireDesiredLRP方法为例：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DesiredLRPHandler)</span> <span class="title">DesireDesiredLRP</span><span class="params">(logger lager.Logger, w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    logger = logger.Session(<span class="string">"desire-lrp"</span>)</span><br><span class="line"></span><br><span class="line">    request := &amp;models.DesireLRPRequest&#123;&#125;</span><br><span class="line">    response := &amp;models.DesiredLRPLifecycleResponse&#123;&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; exitIfUnrecoverable(logger, h.exitChan, response.Error) &#125;()</span><br><span class="line">    <span class="keyword">defer</span> writeResponse(w, response)</span><br><span class="line"></span><br><span class="line">    err := parseRequest(logger, req, request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        response.Error = models.ConvertError(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = h.desiredLRPDB.DesireLRP(logger, request.DesiredLrp)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        response.Error = models.ConvertError(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    desiredLRP, err := h.desiredLRPDB.DesiredLRPByProcessGuid(logger, request.DesiredLrp.ProcessGuid)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        response.Error = models.ConvertError(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> h.desiredHub.Emit(models.NewDesiredLRPCreatedEvent(desiredLRP))</span><br><span class="line"></span><br><span class="line">    schedulingInfo := request.DesiredLrp.DesiredLRPSchedulingInfo()</span><br><span class="line">    h.startInstanceRange(logger, <span class="number">0</span>, schedulingInfo.Instances, &amp;schedulingInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看倒数第三行，可以看到通过h.desiredHub.Emit生成了一个协程执行LRPCreateEvent事件，进入models/events.go查看相关函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDesiredLRPCreatedEvent</span><span class="params">(desiredLRP *DesiredLRP)</span> *<span class="title">DesiredLRPCreatedEvent</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DesiredLRPCreatedEvent&#123;</span><br><span class="line">        DesiredLrp: desiredLRP,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看events/hub.go中的Emit方法，查看其如何处理这类的事件：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hub *hub)</span> <span class="title">Emit</span><span class="params">(event models.Event)</span></span> &#123;</span><br><span class="line">    hub.lock.Lock()</span><br><span class="line">    size := <span class="built_in">len</span>(hub.subscribers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sub, _ := <span class="keyword">range</span> hub.subscribers &#123;</span><br><span class="line">        err := sub.send(event)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">delete</span>(hub.subscribers, sub)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cb <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">len</span><span class="params">(hub.subscribers)</span> != <span class="title">size</span></span> &#123;</span><br><span class="line">        cb = hub.cb</span><br><span class="line">        size = <span class="built_in">len</span>(hub.subscribers)</span><br><span class="line">    &#125;</span><br><span class="line">    hub.lock.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cb != <span class="literal">nil</span> &#123;</span><br><span class="line">        cb(size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看这个文件中hub和hubSource的定义：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hub <span class="keyword">struct</span> &#123;</span><br><span class="line">    subscribers <span class="keyword">map</span>[*hubSource]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    closed      <span class="keyword">bool</span></span><br><span class="line">    lock        sync.Mutex</span><br><span class="line"></span><br><span class="line">    cb <span class="function"><span class="keyword">func</span><span class="params">(count <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">hubSource</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    events        <span class="keyword">chan</span> models.Event</span><br><span class="line">    closeCallback <span class="function"><span class="keyword">func</span><span class="params">(*hubSource)</span></span></span><br><span class="line"><span class="function">    <span class="title">closed</span>        <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">lock</span>          <span class="title">sync</span>.<span class="title">Mutex</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出这是一个封装了channel 和sync.Mutex的结构体，关于hubSource.send方法里面有一个select方法，用法可见这个<a href="http://studygolang.com/articles/2696" target="_blank" rel="noopener">BLOG</a>,所以Emit方法的意义就是如果event进入了channel，则暂时不需要被处理，可以pending，否则调用cb func(int)来处理，并且更新subscribers的数量,cb func(int)的实现未知，而且channel的接收协程也暂时未知。</p>
<p><br><strong>填坑：</strong>channel的接收方法在hubSource.Next()方法中，这也印证了我之前的想法，events.Hub是用来缓存请求的。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(source *hubSource)</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(models.Event, error)</span></span> &#123;</span><br><span class="line">    event, ok := &lt;-source.events</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrReadFromClosedSource</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> event, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br>再回到刚开始的DesireDesiredLRP方法的最后一行，也就是DesiredLRPHandler.startInstanceRange方法，这个方法是真正调用diego中的Auctioneer来启动Instance的方法。</p>
<h4 id="涉及到AuctioneerClient的方法"><a href="#涉及到AuctioneerClient的方法" class="headerlink" title="涉及到AuctioneerClient的方法"></a>涉及到AuctioneerClient的方法</h4><p>DesiredLRPHandler.startInstanceRange方法如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DesiredLRPHandler)</span> <span class="title">startInstanceRange</span><span class="params">(logger lager.Logger, lower, upper <span class="keyword">int32</span>, schedulingInfo *models.DesiredLRPSchedulingInfo)</span></span> &#123;</span><br><span class="line">    logger = logger.Session(<span class="string">"start-instance-range"</span>, lager.Data&#123;<span class="string">"lower"</span>: lower, <span class="string">"upper"</span>: upper&#125;)</span><br><span class="line">    logger.Info(<span class="string">"starting"</span>)</span><br><span class="line">    <span class="keyword">defer</span> logger.Info(<span class="string">"complete"</span>)</span><br><span class="line"></span><br><span class="line">    keys := <span class="built_in">make</span>([]*models.ActualLRPKey, upper-lower)</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> actualIndex := lower; actualIndex &lt; upper; actualIndex++ &#123;</span><br><span class="line">        key := models.NewActualLRPKey(schedulingInfo.ProcessGuid, <span class="keyword">int32</span>(actualIndex), schedulingInfo.Domain)</span><br><span class="line">        keys[i] = &amp;key</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createdIndices := h.createUnclaimedActualLRPs(logger, keys)</span><br><span class="line">    start := auctioneer.NewLRPStartRequestFromSchedulingInfo(schedulingInfo, createdIndices...)</span><br><span class="line"></span><br><span class="line">    logger.Info(<span class="string">"start-lrp-auction-request"</span>, lager.Data&#123;<span class="string">"app_guid"</span>: schedulingInfo.ProcessGuid, <span class="string">"indices"</span>: createdIndices&#125;)</span><br><span class="line">    err := h.auctioneerClient.RequestLRPAuctions(logger, []*auctioneer.LRPStartRequest&#123;&amp;start&#125;)</span><br><span class="line">    logger.Info(<span class="string">"finished-lrp-auction-request"</span>, lager.Data&#123;<span class="string">"app_guid"</span>: schedulingInfo.ProcessGuid, <span class="string">"indices"</span>: createdIndices&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-to-request-auction"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很重要，可以看出这个方法接收了models.DesiredLRPSchedulingInfo以及需要启动的实例个数(lower, upper)来执行讲DesiredLRPC变成ActualLRPs的过程。<br>首先生成了models.ActualLRPKey数组，然后调用了DesiredLRPHandler.createUnclaimedActualLRPs方法来执行任务：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *DesiredLRPHandler)</span> <span class="title">createUnclaimedActualLRPs</span><span class="params">(logger lager.Logger, keys []*models.ActualLRPKey)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">len</span>(keys)</span><br><span class="line">    createdIndicesChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, count)</span><br><span class="line"></span><br><span class="line">    works := <span class="built_in">make</span>([]<span class="function"><span class="keyword">func</span><span class="params">()</span>, <span class="title">count</span>)</span></span><br><span class="line">    logger = logger.Session("create-unclaimed-actual-lrp")</span><br><span class="line">    <span class="keyword">for</span> i, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        key := key</span><br><span class="line">        works[i] = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            logger.Info(<span class="string">"starting"</span>, lager.Data&#123;<span class="string">"actual_lrp_key"</span>: key&#125;)</span><br><span class="line">            actualLRPGroup, err := h.actualLRPDB.CreateUnclaimedActualLRP(logger, key)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logger.Info(<span class="string">"failed"</span>, lager.Data&#123;<span class="string">"actual_lrp_key"</span>: key, <span class="string">"err_message"</span>: err.Error()&#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">go</span> h.actualHub.Emit(models.NewActualLRPCreatedEvent(actualLRPGroup))</span><br><span class="line">                createdIndicesChan &lt;- <span class="keyword">int</span>(key.Index)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throttlerSize := h.updateWorkersCount</span><br><span class="line">    throttler, err := workpool.NewThrottler(throttlerSize, works)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Error(<span class="string">"failed-constructing-throttler"</span>, err, lager.Data&#123;<span class="string">"max_workers"</span>: throttlerSize, <span class="string">"num_works"</span>: <span class="built_in">len</span>(works)&#125;)</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        throttler.Work()</span><br><span class="line">        <span class="built_in">close</span>(createdIndicesChan)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    createdIndices := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, count)</span><br><span class="line">    <span class="keyword">for</span> createdIndex := <span class="keyword">range</span> createdIndicesChan &#123;</span><br><span class="line">        createdIndices = <span class="built_in">append</span>(createdIndices, createdIndex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createdIndices</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出在这个方法中调用了另外一个workpool.NewThrottler方法来执行方法中的works函数，因此可以进入此查看实现过程（我感觉此对象（接口）中完成了我们前面提到的evnethub所生成的事件的处理工作）：<br>查看workpool/throttler.go中的相关方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Throttler <span class="keyword">struct</span> &#123;</span><br><span class="line">    pool  *WorkPool</span><br><span class="line">    works []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewThrottler</span><span class="params">(maxWorkers <span class="keyword">int</span>, works []<span class="keyword">func</span>()</span>) <span class="params">(*Throttler, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> maxWorkers &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"must provide positive maxWorkers; provided %d"</span>, maxWorkers)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pool *WorkPool</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(works) &lt; maxWorkers &#123;</span><br><span class="line">        pool = newWorkPoolWithPending(<span class="built_in">len</span>(works), <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pool = newWorkPoolWithPending(maxWorkers, <span class="built_in">len</span>(works)-maxWorkers)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;Throttler&#123;</span><br><span class="line">        pool:  pool,</span><br><span class="line">        works: works,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Throttler)</span> <span class="title">Work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> t.pool.Stop()</span><br><span class="line"></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(t.works))</span><br><span class="line">    <span class="keyword">for</span> _, work := <span class="keyword">range</span> t.works &#123;</span><br><span class="line">        work := work</span><br><span class="line">        t.pool.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            work()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到前面的代码中可以看到auctioneer.NewLRPStartRequestFromSchedulingInfo以及auctioneerClient.RequestLRPAuctions方法，可以从auctioneer 包中看到client.go方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:generate counterfeiter -o auctioneerfakes/fake_client.go . Client</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">interface</span> &#123;</span><br><span class="line">    RequestLRPAuctions(logger lager.Logger, lrpStart []*LRPStartRequest) error</span><br><span class="line">    RequestTaskAuctions(logger lager.Logger, tasks []*TaskStartRequest) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> auctioneerClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    httpClient         *http.Client</span><br><span class="line">    insecureHTTPClient *http.Client</span><br><span class="line">    url                <span class="keyword">string</span></span><br><span class="line">    requireTLS         <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(auctioneerURL <span class="keyword">string</span>)</span> <span class="title">Client</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;auctioneerClient&#123;</span><br><span class="line">        httpClient: cfhttp.NewClient(),</span><br><span class="line">        url:        auctioneerURL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *auctioneerClient)</span> <span class="title">RequestLRPAuctions</span><span class="params">(logger lager.Logger, lrpStarts []*LRPStartRequest)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    logger = logger.Session(<span class="string">"request-lrp-auctions"</span>)</span><br><span class="line"></span><br><span class="line">    reqGen := rata.NewRequestGenerator(c.url, Routes)</span><br><span class="line">    payload, err := json.Marshal(lrpStarts)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req, err := reqGen.CreateRequest(CreateLRPAuctionsRoute, rata.Params&#123;&#125;, bytes.NewBuffer(payload))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line"></span><br><span class="line">    resp, err := c.doRequest(logger, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusAccepted &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"http error: status code %d (%s)"</span>, resp.StatusCode, http.StatusText(resp.StatusCode))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *auctioneerClient)</span> <span class="title">RequestTaskAuctions</span><span class="params">(logger lager.Logger, tasks []*TaskStartRequest)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    logger = logger.Session(<span class="string">"request-task-auctions"</span>)</span><br><span class="line"></span><br><span class="line">    reqGen := rata.NewRequestGenerator(c.url, Routes)</span><br><span class="line">    payload, err := json.Marshal(tasks)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req, err := reqGen.CreateRequest(CreateTaskAuctionsRoute, rata.Params&#123;&#125;, bytes.NewBuffer(payload))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line"></span><br><span class="line">    resp, err := c.doRequest(logger, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusAccepted &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"http error: status code %d (%s)"</span>, resp.StatusCode, http.StatusText(resp.StatusCode))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *auctioneerClient)</span> <span class="title">doRequest</span><span class="params">(logger lager.Logger, req *http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line">    resp, err := c.httpClient.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Fall back to HTTP and try again if we do not require TLS</span></span><br><span class="line">        <span class="keyword">if</span> !c.requireTLS &amp;&amp; c.insecureHTTPClient != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Error(<span class="string">"retrying-on-http"</span>, err)</span><br><span class="line">            req.URL.Scheme = <span class="string">"http"</span></span><br><span class="line">            <span class="keyword">return</span> c.insecureHTTPClient.Do(req)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resp, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>关于golang的interface介绍</strong>：interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/02.6.md" target="_blank" rel="noopener">Interface</a><br>可见在这个方法中，利用rata生成了一个reqGen来处理tasks任务，然后调用reqGen.CreateRequest()和httpClient.Do()来处理请求。更多的关于rata的信息，可见<a href="https://github.com/tedsuo/rata" target="_blank" rel="noopener">POST</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/06/auctioineerCP/" class="prev">PREV</a><a href="/2018/09/06/BBSinCloudFoundry(2)/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>